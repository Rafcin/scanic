{"version":3,"file":"scanic.js","sources":["../src/constants.js","../src/contourDetection.js","../src/cornerDetection.js","../wasm_blur/pkg/wasm_blur.js","../src/edgeDetection.js","../src/enhancedDetection.js","../src/index.js"],"sourcesContent":["/**\r\n * Constants used throughout the library\r\n */\r\n\r\nexport const VERSION = '1.0.0';\r\n\r\nexport const DEFAULTS = {\r\n  // Edge detection params\r\n  GAUSSIAN_SIGMA: 1.1,\r\n  LOW_THRESHOLD: 50,\r\n  HIGH_THRESHOLD: 150,\r\n  \r\n  // Contour detection params\r\n  MIN_CONTOUR_AREA: 1000,\r\n  MIN_CONTOUR_POINTS: 10,\r\n  \r\n  // Debug options\r\n  DEBUG_OVERLAY_OPACITY: 0.7\r\n};","/**\r\n * Pure JavaScript implementation of contour detection algorithms\r\n * Based on Suzuki, S. and Abe, K. (1985). Topological structural analysis of digitized binary images by border following.\r\n * Replaces the previous flood-fill based connected components analysis.\r\n */\r\n\r\nimport { DEFAULTS } from './constants.js';\r\n\r\n// Constants for different retrieval modes (subset of OpenCV)\r\nconst RETR_EXTERNAL = 0;\r\nconst RETR_LIST = 1;\r\n// Constants for different approximation methods (subset of OpenCV)\r\nconst CHAIN_APPROX_NONE = 1;\r\nconst CHAIN_APPROX_SIMPLE = 2;\r\n\r\n// Deltas for 8-connectivity neighborhood checks (0-7 clockwise from top)\r\n// Corresponds to OpenCV's chain code directions\r\nconst deltas = [\r\n  { dx:  0, dy: -1 }, // 0: Top\r\n  { dx:  1, dy: -1 }, // 1: Top-right\r\n  { dx:  1, dy:  0 }, // 2: Right\r\n  { dx:  1, dy:  1 }, // 3: Bottom-right\r\n  { dx:  0, dy:  1 }, // 4: Bottom\r\n  { dx: -1, dy:  1 }, // 5: Bottom-left\r\n  { dx: -1, dy:  0 }, // 6: Left\r\n  { dx: -1, dy: -1 }  // 7: Top-left\r\n];\r\n\r\n/**\r\n * Detects contours in a binary edge image using Suzuki's border following algorithm.\r\n * @param {Uint8ClampedArray} edges - Binary edge image (pixels > 0 are foreground)\r\n * @param {Object} options - Configuration options\r\n * @param {number} [options.width] - Image width (required if not square)\r\n * @param {number} [options.height] - Image height (required if not square)\r\n * @param {number} [options.mode=RETR_LIST] - Contour retrieval mode (RETR_EXTERNAL or RETR_LIST)\r\n * @param {number} [options.method=CHAIN_APPROX_SIMPLE] - Contour approximation method (CHAIN_APPROX_NONE or CHAIN_APPROX_SIMPLE)\r\n * @param {number} [options.minArea=DEFAULTS.MIN_CONTOUR_AREA] - Minimum contour area filter (applied after detection)\r\n * @param {Object} [options.debug] - Optional debug object to store intermediate results\r\n * @returns {Array} Array of contours, each contour is an array of points {x, y}. Sorted by area (largest first).\r\n */\r\nexport function detectDocumentContour(edges, options = {}) {\r\n  const width = options.width || Math.sqrt(edges.length);\r\n  const height = options.height || edges.length / width;\r\n  const mode = options.mode !== undefined ? options.mode : RETR_LIST;\r\n  const method = options.method !== undefined ? options.method : CHAIN_APPROX_SIMPLE;\r\n  const minArea = options.minArea || DEFAULTS.MIN_CONTOUR_AREA;\r\n\r\n  // Create a padded label map to simplify boundary checks.\r\n  // 0: background\r\n  // 1: foreground (unlabeled)\r\n  // >= 2: contour ID (2, 3, ...)\r\n  const paddedWidth = width + 2;\r\n  const paddedHeight = height + 2;\r\n  const labels = new Int32Array(paddedWidth * paddedHeight); // Initialized to 0\r\n\r\n  // Copy edges data to the label map, mapping foreground pixels to 1\r\n  for (let y = 0; y < height; y++) {\r\n    for (let x = 0; x < width; x++) {\r\n      if (edges[y * width + x] > 0) {\r\n        labels[(y + 1) * paddedWidth + (x + 1)] = 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  const contours = [];\r\n  let nextContourId = 2; // Start labeling contours from 2\r\n\r\n  // Raster scan\r\n  for (let y = 1; y <= height; y++) {\r\n    for (let x = 1; x <= width; x++) {\r\n      const currentPixelLabel = labels[y * paddedWidth + x];\r\n      const leftPixelLabel = labels[y * paddedWidth + (x - 1)];\r\n\r\n      let startPoint = null;\r\n      let isOuter = false;\r\n      let initialDirection = -1;\r\n\r\n      if (currentPixelLabel === 1 && leftPixelLabel === 0) {\r\n        // Found the start of an outer contour boundary (NBD = 1 in Suzuki's terms)\r\n        isOuter = true;\r\n        startPoint = { x: x, y: y };\r\n        initialDirection = 2; // Start searching right\r\n        // if (options.debug) console.log(`Outer contour start at (${x-1}, ${y-1})`);\r\n      } else if (currentPixelLabel === 0 && leftPixelLabel >= 1 && leftPixelLabel !== -1) {\r\n         // Found the start of a hole contour boundary (NBD >= 2 in Suzuki's terms)\r\n         // Check if the left pixel is already part of a traced contour border\r\n         // If leftPixelLabel is > 1, it might be already traced. If it's 1, it's an unlabeled foreground pixel.\r\n         // We only start tracing if the left pixel is unlabeled foreground (1).\r\n         if (leftPixelLabel === 1) {\r\n             isOuter = false;\r\n             startPoint = { x: x - 1, y: y };\r\n             initialDirection = 6; // Start searching left\r\n            //  if (options.debug) console.log(`Hole contour start at (${x-1-1}, ${y-1})`);\r\n         }\r\n      }\r\n\r\n\r\n      if (startPoint) {\r\n        // If mode is RETR_EXTERNAL, only process outer contours\r\n        if (mode === RETR_EXTERNAL && !isOuter) {\r\n          // Mark the starting pixel of the hole so we don't process it again\r\n          // Use a special marker (-1) to distinguish from contour IDs\r\n           labels[startPoint.y * paddedWidth + startPoint.x] = -1;\r\n           continue;\r\n        }\r\n\r\n        const contourId = nextContourId++;\r\n        const points = traceContour(labels, paddedWidth, paddedHeight, startPoint, initialDirection, contourId);\r\n\r\n        if (points && points.length > 0) {\r\n            let finalPoints = points;\r\n            if (method === CHAIN_APPROX_SIMPLE) {\r\n                finalPoints = simplifyChainApproxSimple(points);\r\n            }\r\n\r\n            // Adjust points to original image coordinates (remove padding offset)\r\n            const adjustedPoints = finalPoints.map(p => ({ x: p.x - 1, y: p.y - 1 }));\r\n\r\n            if (adjustedPoints.length >= (method === CHAIN_APPROX_SIMPLE ? 4 : DEFAULTS.MIN_CONTOUR_POINTS)) { // Need at least 4 points for a simple polygon approx\r\n                const contour = {\r\n                    id: contourId,\r\n                    points: adjustedPoints,\r\n                    isOuter: isOuter,\r\n                    // Calculate area and bounding box later if needed for filtering/sorting\r\n                };\r\n                contours.push(contour);\r\n            }\r\n        } else {\r\n             // Handle single point contours or errors if necessary\r\n             // Mark the start point if trace failed or resulted in no points\r\n             if (labels[startPoint.y * paddedWidth + startPoint.x] === 1) {\r\n                 labels[startPoint.y * paddedWidth + startPoint.x] = contourId; // Mark as visited\r\n             }\r\n        }\r\n      } else if (currentPixelLabel >= 1 && leftPixelLabel >= 1 && currentPixelLabel !== leftPixelLabel) {\r\n          // Handle merging contours or complex topology if needed (not implemented for RETR_LIST/EXTERNAL)\r\n      }\r\n    }\r\n  }\r\n\r\n  // Calculate area and bounding box for filtering and sorting\r\n  contours.forEach(contour => {\r\n    contour.area = calculateContourArea(contour.points);\r\n    contour.boundingBox = calculateBoundingBox(contour.points);\r\n  });\r\n\r\n  // Filter by minimum area\r\n  const filteredContours = contours.filter(contour => contour.area >= minArea);\r\n\r\n  // Sort contours by area (largest first)\r\n  filteredContours.sort((a, b) => b.area - a.area);\r\n\r\n  // console.log(`Found ${contours.length} contours before filtering, ${filteredContours.length} after filtering.`);\r\n\r\n  // Store debug info if requested\r\n  if (options.debug) {\r\n    options.debug.labels = labels; // Store the final label map\r\n    options.debug.rawContours = contours; // Store contours before filtering/sorting\r\n    options.debug.finalContours = filteredContours;\r\n    // console.log('Contour detection debug info stored');\r\n  }\r\n  return filteredContours // Return only the points array per contour\r\n}\r\n\r\n/**\r\n * Traces a contour boundary using border following.\r\n * @param {Int32Array} labels - The label map (modified during tracing)\r\n * @param {number} width - Padded width of the label map\r\n * @param {number} height - Padded height of the label map\r\n * @param {Object} startPoint - Starting point {x, y} in padded coordinates\r\n * @param {number} initialDirection - Initial search direction (0-7)\r\n * @param {number} contourId - The ID to label this contour with\r\n * @returns {Array} Array of points {x, y} in padded coordinates, or null if error\r\n */\r\nfunction traceContour(labels, width, height, startPoint, initialDirection, contourId) {\r\n    const points = [];\r\n    const visitedPoints = new Set(); // Use a Set for efficient duplicate checking\r\n    let currentPoint = { ...startPoint };\r\n    let prevDirection = -1; // Store the direction from which we arrived at currentPoint\r\n\r\n    // Mark the starting pixel with the contour ID\r\n    labels[startPoint.y * width + startPoint.x] = contourId;\r\n\r\n    let count = 0; // Safety break\r\n    const maxSteps = width * height; // Max possible steps\r\n\r\n    while (count++ < maxSteps) {\r\n        // Determine the direction to start searching from (relative to the direction we came from)\r\n        // In Suzuki's paper, this is based on the chain code of the previous step.\r\n        // Simplified: Start searching from the direction after the one that led us here.\r\n        // If we arrived from direction `d`, the next pixel must be in `(d+1)%8` to `(d+7)%8`.\r\n        // Let's adapt OpenCV's logic: search starts from (prevDirection + 2) % 8 clockwise.\r\n        // If it's the first step, prevDirection is unknown, use initialDirection logic.\r\n\r\n        let searchDirection;\r\n        if (prevDirection === -1) {\r\n            // First step: Use initialDirection logic (e.g., start right for outer, left for inner)\r\n            // The initial search should find the *first* pixel of the contour boundary clockwise.\r\n            // Let's refine the initial search based on OpenCV's approach:\r\n            // Find the first non-zero pixel starting from `initialDirection` clockwise.\r\n            let found = false;\r\n            for (let i = 0; i < 8; i++) {\r\n                searchDirection = (initialDirection + i) % 8;\r\n                const nextX = currentPoint.x + deltas[searchDirection].dx;\r\n                const nextY = currentPoint.y + deltas[searchDirection].dy;\r\n                if (nextX >= 0 && nextX < width && nextY >= 0 && nextY < height && labels[nextY * width + nextX] > 0) {\r\n                    found = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!found) return null; // Should not happen if startPoint is valid\r\n\r\n        } else {\r\n            // Subsequent steps: Start search from (prevDirection + 2) % 8 clockwise\r\n             searchDirection = (prevDirection + 2) % 8;\r\n        }\r\n\r\n\r\n        let nextPoint = null;\r\n        let nextDirection = -1;\r\n\r\n        // Search clockwise for the next boundary pixel\r\n        for (let i = 0; i < 8; i++) {\r\n            const checkDirection = (searchDirection + i) % 8;\r\n            const checkX = currentPoint.x + deltas[checkDirection].dx;\r\n            const checkY = currentPoint.y + deltas[checkDirection].dy;\r\n\r\n            // Check bounds (should be within padded area)\r\n            if (checkX >= 0 && checkX < width && checkY >= 0 && checkY < height) {\r\n                const pixelLabel = labels[checkY * width + checkX];\r\n                if (pixelLabel > 0) { // Found a foreground pixel (labeled or unlabeled)\r\n                    nextPoint = { x: checkX, y: checkY };\r\n                    // The direction *from* currentPoint *to* nextPoint is checkDirection\r\n                    nextDirection = checkDirection;\r\n                    // The direction *from* which we will arrive *at* nextPoint is (checkDirection + 4) % 8\r\n                    prevDirection = (checkDirection + 4) % 8;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!nextPoint) {\r\n            // Should not happen in a well-formed contour, maybe isolated pixel?\r\n             if (points.length === 0) { // If it's just the start point\r\n                 points.push({ ...currentPoint }); // Add the single point\r\n             }\r\n            console.warn(`Contour tracing stopped unexpectedly at (${currentPoint.x-1}, ${currentPoint.y-1}) for contour ${contourId}`);\r\n            break;\r\n        }\r\n\r\n        // Add the *current* point to the list before moving\r\n        const pointKey = `${currentPoint.x},${currentPoint.y}`;\r\n        if (visitedPoints.has(pointKey)) {\r\n            // console.warn(`Duplicate point detected at (${currentPoint.x}, ${currentPoint.y}) for contour ${contourId}`);\r\n            // console.warn(points)\r\n            // console.warn(filtered)\r\n            return points; // Avoid infinite loops on duplicate points\r\n        }\r\n        points.push({ ...currentPoint });\r\n        visitedPoints.add(pointKey);\r\n        \r\n\r\n        // Mark the next pixel if it's unlabeled\r\n        if (labels[nextPoint.y * width + nextPoint.x] === 1) {\r\n            labels[nextPoint.y * width + nextPoint.x] = contourId;\r\n        }\r\n\r\n        // Move to the next point\r\n        currentPoint = nextPoint;\r\n\r\n        // Check if we returned to the start point\r\n        if (currentPoint.x === startPoint.x && currentPoint.y === startPoint.y) {\r\n            // Check if we came from the same direction as the initial step search ended.\r\n            // This is complex, let's use a simpler check: if we are back at start, we are done.\r\n            // OpenCV has more sophisticated checks involving i4 == i0 && i3 == i1.\r\n            break;\r\n        }\r\n    }\r\n\r\n     if (count >= maxSteps) {\r\n        console.warn(`Contour tracing exceeded max steps for contour ${contourId}`);\r\n        return null; // Indicate potential error\r\n    }\r\n\r\n    return points;\r\n}\r\n\r\n/**\r\n * Simplifies a contour polygon using CHAIN_APPROX_SIMPLE.\r\n * Removes intermediate points that lie on the straight line segment between their neighbors.\r\n * @param {Array} points - Array of contour points {x, y}\r\n * @returns {Array} Simplified array of points\r\n */\r\nfunction simplifyChainApproxSimple(points) {\r\n    if (points.length <= 2) {\r\n        return points;\r\n    }\r\n\r\n    const simplifiedPoints = [];\r\n    const n = points.length;\r\n\r\n    for (let i = 0; i < n; i++) {\r\n        const prevPoint = points[(i + n - 1) % n]; // Handle wrap around\r\n        const currentPoint = points[i];\r\n        const nextPoint = points[(i + 1) % n]; // Handle wrap around\r\n\r\n        // Check for collinearity: (y2-y1)*(x3-x2) == (y3-y2)*(x2-x1)\r\n        const dx1 = currentPoint.x - prevPoint.x;\r\n        const dy1 = currentPoint.y - prevPoint.y;\r\n        const dx2 = nextPoint.x - currentPoint.x;\r\n        const dy2 = nextPoint.y - currentPoint.y;\r\n\r\n        // If points are not collinear, keep the current point\r\n        if (dx1 * dy2 !== dy1 * dx2) {\r\n            simplifiedPoints.push(currentPoint);\r\n        }\r\n    }\r\n\r\n    // Handle cases where all points are collinear (e.g., straight line)\r\n    // In this case, the above loop might remove all points. Keep first and last?\r\n    // OpenCV keeps the two endpoints of the line segment.\r\n    if (simplifiedPoints.length === 0 && n > 0) {\r\n         // If all points were collinear, return the start and end points of the original sequence\r\n         // This requires knowing the original start/end, which isn't trivial with wrap-around.\r\n         // Let's return the first and the point furthest from the first.\r\n         if (n === 1) return [points[0]];\r\n         if (n === 2) return points;\r\n\r\n         // Find the point most distant from the first point to represent the line segment\r\n         let maxDistSq = 0;\r\n         let farthestIdx = 1;\r\n         const p0 = points[0];\r\n         for(let i = 1; i < n; i++) {\r\n             const pi = points[i];\r\n             const distSq = (pi.x - p0.x)**2 + (pi.y - p0.y)**2;\r\n             if (distSq > maxDistSq) {\r\n                 maxDistSq = distSq;\r\n                 farthestIdx = i;\r\n             }\r\n         }\r\n         // Ensure order if needed, but for simple approx, just two points is fine.\r\n         return [points[0], points[farthestIdx]];\r\n    }\r\n\r\n\r\n    return simplifiedPoints;\r\n}\r\n\r\n\r\n// --- Helper functions (keep or adapt from original) ---\r\n\r\n/**\r\n * Calculates the area of a contour using the shoelace formula\r\n * @param {Array} points - Array of point coordinates {x, y}\r\n * @returns {number} Contour area\r\n */\r\nfunction calculateContourArea(points) {\r\n  let area = 0;\r\n  const n = points.length;\r\n\r\n  if (n < 3) return 0;\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    const j = (i + 1) % n;\r\n    area += points[i].x * points[j].y;\r\n    area -= points[j].x * points[i].y;\r\n  }\r\n\r\n  return Math.abs(area) / 2;\r\n}\r\n\r\n/**\r\n * Calculates the bounding box of a contour\r\n * @param {Array} points - Array of point coordinates\r\n * @returns {Object} Bounding box with minX, minY, maxX, maxY properties\r\n */\r\nfunction calculateBoundingBox(points) {\r\n  if (points.length === 0) {\r\n      return { minX: 0, minY: 0, maxX: 0, maxY: 0 };\r\n  }\r\n  let minX = points[0].x;\r\n  let minY = points[0].y;\r\n  let maxX = points[0].x;\r\n  let maxY = points[0].y;\r\n\r\n  for (let i = 1; i < points.length; i++) {\r\n      const point = points[i];\r\n      minX = Math.min(minX, point.x);\r\n      minY = Math.min(minY, point.y);\r\n      maxX = Math.max(maxX, point.x);\r\n      maxY = Math.max(maxY, point.y);\r\n  }\r\n\r\n  return { minX, minY, maxX, maxY };\r\n}\r\n\r\n\r\n// --- Functions below are no longer directly used by detectDocumentContour ---\r\n// --- but might be useful elsewhere or can be removed ---\r\n\r\n/**\r\n * Simplifies a contour using the Ramer-Douglas-Peucker algorithm\r\n * (No longer used by default contour detection, kept for potential external use)\r\n * @param {Array} points - Array of point coordinates\r\n * @param {number} epsilon - Epsilon value for simplification\r\n * @returns {Array} Simplified contour points\r\n */\r\nexport function simplifyContour(points, epsilon = 1.0) {\r\n  // ... (keep existing implementation if needed elsewhere) ...\r\n   if (points.length <= 2) {\r\n    return points;\r\n  }\r\n\r\n  // Find point with the maximum distance\r\n  let maxDistance = 0;\r\n  let index = 0;\r\n\r\n  const firstPoint = points[0];\r\n  const lastPoint = points[points.length - 1];\r\n\r\n  for (let i = 1; i < points.length - 1; i++) {\r\n    const distance = perpendicularDistance(points[i], firstPoint, lastPoint);\r\n\r\n    if (distance > maxDistance) {\r\n      maxDistance = distance;\r\n      index = i;\r\n    }\r\n  }\r\n\r\n  // If max distance is greater than epsilon, recursively simplify\r\n  if (maxDistance > epsilon) {\r\n    // Recursive simplification\r\n    const firstSegment = simplifyContour(points.slice(0, index + 1), epsilon);\r\n    const secondSegment = simplifyContour(points.slice(index), epsilon);\r\n\r\n    // Concatenate the two segments\r\n    return firstSegment.slice(0, -1).concat(secondSegment);\r\n  } else {\r\n    // Return just the endpoints\r\n    return [firstPoint, lastPoint];\r\n  }\r\n}\r\n\r\n/**\r\n * Calculates the perpendicular distance from a point to a line\r\n * (Helper for RDP simplifyContour, keep if that function is kept)\r\n * @param {Object} point - Point to measure from\r\n * @param {Object} lineStart - Start point of the line\r\n * @param {Object} lineEnd - End point of the line\r\n * @returns {number} Perpendicular distance\r\n */\r\nfunction perpendicularDistance(point, lineStart, lineEnd) {\r\n // ... (keep existing implementation if needed elsewhere) ...\r\n   const dx = lineEnd.x - lineStart.x;\r\n  const dy = lineEnd.y - lineStart.y;\r\n\r\n  // Line length squared\r\n  const lineLengthSq = dx * dx + dy * dy;\r\n\r\n  if (lineLengthSq === 0) {\r\n    // Point to point distance if the line has zero length\r\n    return Math.sqrt(\r\n      Math.pow(point.x - lineStart.x, 2) +\r\n      Math.pow(point.y - lineStart.y, 2)\r\n    );\r\n  }\r\n\r\n   // Calculate the projection parameter t\r\n  const t = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / lineLengthSq;\r\n\r\n  let closestPointX, closestPointY;\r\n\r\n  if (t < 0) {\r\n    closestPointX = lineStart.x;\r\n    closestPointY = lineStart.y;\r\n  } else if (t > 1) {\r\n    closestPointX = lineEnd.x;\r\n    closestPointY = lineEnd.y;\r\n  } else {\r\n    closestPointX = lineStart.x + t * dx;\r\n    closestPointY = lineStart.y + t * dy;\r\n  }\r\n\r\n  // Calculate the distance from the point to the closest point on the line segment\r\n  const distDx = point.x - closestPointX;\r\n  const distDy = point.y - closestPointY;\r\n  return Math.sqrt(distDx * distDx + distDy * distDy);\r\n\r\n  /* // Original implementation using area formula (distance to infinite line)\r\n  const lineLength = Math.sqrt(lineLengthSq);\r\n  const area = Math.abs(dy * point.x - dx * point.y + lineEnd.x * lineStart.y - lineEnd.y * lineStart.x);\r\n  return area / lineLength;\r\n  */\r\n}\r\n\r\n/**\r\n * Creates a polygon approximation of a contour using RDP.\r\n * (No longer used by default contour detection, kept for potential external use)\r\n * @param {Array} contourPoints - Array of points {x, y}\r\n * @param {number} epsilon - Epsilon for polygon approximation (relative to perimeter)\r\n * @returns {Array} Array of polygon points\r\n */\r\nexport function approximatePolygon(contourPoints, epsilon = 0.02) {\r\n  // Calculate contour perimeter\r\n  const perimeter = calculateContourPerimeter(contourPoints);\r\n\r\n  // Calculate epsilon based on perimeter\r\n  const actualEpsilon = epsilon * perimeter;\r\n\r\n  // Simplify the contour using RDP\r\n  const simplifiedPoints = simplifyContour(contourPoints, actualEpsilon);\r\n\r\n  return simplifiedPoints;\r\n}\r\n\r\n/**\r\n * Calculates the perimeter of a contour\r\n * (Helper for RDP approximatePolygon, keep if that function is kept)\r\n * @param {Array} points - Array of point coordinates\r\n * @returns {number} Contour perimeter\r\n */\r\nfunction calculateContourPerimeter(points) {\r\n // ... (keep existing implementation if needed elsewhere) ...\r\n   let perimeter = 0;\r\n  const n = points.length;\r\n\r\n  if (n < 2) return 0;\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    const j = (i + 1) % n; // Wrap around for the last segment\r\n    const dx = points[i].x - points[j].x;\r\n    const dy = points[i].y - points[j].y;\r\n    perimeter += Math.sqrt(dx * dx + dy * dy);\r\n  }\r\n\r\n  return perimeter;\r\n}\r\n\r\n// Flood fill is no longer used for contour detection\r\n/*\r\nfunction floodFill(edges, labels, width, height, startX, startY, label) {\r\n  // ... (original floodFill implementation removed) ...\r\n}\r\n*/","/**\r\n * Pure JavaScript implementation for detecting corners of a document\r\n * Replaces OpenCV's corner detection and point finding logic\r\n */\r\n\r\nimport { approximatePolygon } from './contourDetection.js';\r\n\r\n/**\r\n * Calculate distance between two points\r\n * @param {Object} p1 - First point {x, y}\r\n * @param {Object} p2 - Second point {x, y}\r\n * @returns {number} Distance between points\r\n */\r\nexport function distance(p1, p2) {\r\n  return Math.hypot(p2.x - p1.x, p2.y - p1.y);\r\n}\r\n\r\n/**\r\n * Find the center point of a contour\r\n * @param {Array} points - Array of contour points\r\n * @returns {Object} Center point {x, y}\r\n */\r\nfunction findCenter(points) {\r\n  let sumX = 0;\r\n  let sumY = 0;\r\n  \r\n  for (const point of points) {\r\n    sumX += point.x;\r\n    sumY += point.y;\r\n  }\r\n  \r\n  return {\r\n    x: sumX / points.length,\r\n    y: sumY / points.length\r\n  };\r\n}\r\n\r\n/**\r\n * Find the four corners of a document contour\r\n * @param {Object} contour - Contour object with points property\r\n * @param {Object} options - Configuration options\r\n * @returns {Object} Object with topLeft, topRight, bottomRight, bottomLeft corners\r\n */\r\nexport function findCornerPoints(contour, options = {}) {\r\n  if (!contour || !contour.points || contour.points.length < 4) {\r\n    console.warn('Contour does not have enough points for corner detection');\r\n    return null;\r\n  }\r\n  \r\n  // Try to find a quadrilateral approximation of the contour\r\n  const epsilon = options.epsilon || 0.02;\r\n  const approximation = approximatePolygon(contour, epsilon);\r\n  \r\n  let corners;\r\n  \r\n  // If we get exactly 4 points, we can use them as corners\r\n  if (approximation && approximation.length === 4) {\r\n    // console.log('Found 4-point approximation, using as corners');\r\n    corners = orderCornerPoints(approximation);\r\n  } else {\r\n    // console.log(`Polygon approximation gave ${approximation ? approximation.length : 'null'} points, using coordinate extremes method`);\r\n    // Fallback: Use the coordinate extremes method on the original contour points\r\n    corners = findCornersByCoordinateExtremes(contour.points); \r\n  }\r\n  \r\n  // Ensure all corners were found\r\n  if (!corners || !corners.topLeft || !corners.topRight || !corners.bottomRight || !corners.bottomLeft) {\r\n      console.warn('Failed to find all four corners.', corners);\r\n      // Return null or partial corners? Returning null might be safer downstream.\r\n      return null; \r\n  }\r\n\r\n  // Debug info\r\n  console.log('Corner points:', corners);\r\n  return corners;\r\n}\r\n\r\n/**\r\n * Find corners by finding points with min/max coordinate sums/differences.\r\n * This is an alternative heuristic for finding corners.\r\n * @param {Array} points - Array of contour points\r\n * @returns {Object} Object with topLeft, topRight, bottomRight, bottomLeft corners\r\n */\r\nfunction findCornersByCoordinateExtremes(points) {\r\n  if (!points || points.length === 0) return null;\r\n\r\n  let topLeft = points[0];      // Min sum x + y\r\n  let topRight = points[0];     // Max diff x - y\r\n  let bottomRight = points[0];  // Max sum x + y\r\n  let bottomLeft = points[0];   // Min diff x - y\r\n\r\n  let minSum = topLeft.x + topLeft.y;\r\n  let maxDiff = topRight.x - topRight.y;\r\n  let maxSum = bottomRight.x + bottomRight.y;\r\n  let minDiff = bottomLeft.x - bottomLeft.y;\r\n\r\n  for (let i = 1; i < points.length; i++) {\r\n    const point = points[i];\r\n    const sum = point.x + point.y;\r\n    const diff = point.x - point.y;\r\n\r\n    // Top-Left (min sum)\r\n    if (sum < minSum) {\r\n      minSum = sum;\r\n      topLeft = point;\r\n    }\r\n    // Bottom-Right (max sum)\r\n    if (sum > maxSum) {\r\n      maxSum = sum;\r\n      bottomRight = point;\r\n    }\r\n    // Top-Right (max diff)\r\n    if (diff > maxDiff) {\r\n      maxDiff = diff;\r\n      topRight = point;\r\n    }\r\n    // Bottom-Left (min diff)\r\n    if (diff < minDiff) {\r\n      minDiff = diff;\r\n      bottomLeft = point;\r\n    }\r\n  }\r\n\r\n  return {\r\n    topLeft,\r\n    topRight,\r\n    bottomRight,\r\n    bottomLeft\r\n  };\r\n}\r\n\r\n/**\r\n * Orders 4 points in clockwise order starting from top-left\r\n * @param {Array} points - Array of 4 points to order\r\n * @returns {Object} Object with ordered points\r\n */\r\nfunction orderCornerPoints(points) {\r\n  if (points.length !== 4) {\r\n    console.warn(`Expected 4 points, got ${points.length}`);\r\n    return null;\r\n  }\r\n  \r\n  // Calculate centroid\r\n  const center = findCenter(points);\r\n  \r\n  // Sort the points by their angles relative to the center\r\n  const sortedPoints = [...points].sort((a, b) => {\r\n    const angleA = Math.atan2(a.y - center.y, a.x - center.x);\r\n    const angleB = Math.atan2(b.y - center.y, b.x - center.x);\r\n    return angleA - angleB;\r\n  });\r\n  \r\n  // Now find the top-left point (minimum sum of x and y)\r\n  let minSum = Infinity;\r\n  let minIndex = 0;\r\n  \r\n  for (let i = 0; i < 4; i++) {\r\n    const sum = sortedPoints[i].x + sortedPoints[i].y;\r\n    if (sum < minSum) {\r\n      minSum = sum;\r\n      minIndex = i;\r\n    }\r\n  }\r\n  \r\n  // Reorder array to start with the top-left point\r\n  const orderedPoints = [\r\n    sortedPoints[minIndex],\r\n    sortedPoints[(minIndex + 1) % 4],\r\n    sortedPoints[(minIndex + 2) % 4],\r\n    sortedPoints[(minIndex + 3) % 4]\r\n  ];\r\n  \r\n  // Return as named corners\r\n  return {\r\n    topLeft: orderedPoints[0],\r\n    topRight: orderedPoints[1],\r\n    bottomRight: orderedPoints[2],\r\n    bottomLeft: orderedPoints[3]\r\n  };\r\n}","let wasm;\n\nlet cachedFloat32ArrayMemory0 = null;\n\nfunction getFloat32ArrayMemory0() {\n    if (cachedFloat32ArrayMemory0 === null || cachedFloat32ArrayMemory0.byteLength === 0) {\n        cachedFloat32ArrayMemory0 = new Float32Array(wasm.memory.buffer);\n    }\n    return cachedFloat32ArrayMemory0;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArrayF32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\n    getFloat32ArrayMemory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction getArrayF32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getFloat32ArrayMemory0().subarray(ptr / 4, ptr / 4 + len);\n}\n/**\n * Find the best quadrilateral from detected lines\n * Returns: [tl_x, tl_y, tr_x, tr_y, br_x, br_y, bl_x, bl_y, confidence]\n * @param {Float32Array} lines\n * @param {number} width\n * @param {number} height\n * @param {number} min_area_ratio\n * @param {number} max_area_ratio\n * @returns {Float32Array}\n */\nexport function find_document_quadrilateral(lines, width, height, min_area_ratio, max_area_ratio) {\n    const ptr0 = passArrayF32ToWasm0(lines, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.find_document_quadrilateral(ptr0, len0, width, height, min_area_ratio, max_area_ratio);\n    var v2 = getArrayF32FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n    return v2;\n}\n\n/**\n * Find intersections between lines (for corner detection)\n * Input: array from hough_lines [rho0, theta0, votes0, ...]\n * Returns: [x0, y0, line1_idx, line2_idx, ...]\n * @param {Float32Array} lines\n * @param {number} width\n * @param {number} height\n * @param {number} min_angle_diff\n * @returns {Float32Array}\n */\nexport function find_line_intersections(lines, width, height, min_angle_diff) {\n    const ptr0 = passArrayF32ToWasm0(lines, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.find_line_intersections(ptr0, len0, width, height, min_angle_diff);\n    var v2 = getArrayF32FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n    return v2;\n}\n\nlet cachedUint8ArrayMemory0 = null;\n\nfunction getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1, 1) >>> 0;\n    getUint8ArrayMemory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n * Probabilistic Hough Line Transform (faster, returns line segments)\n * Returns flattened array: [x1_0, y1_0, x2_0, y2_0, votes0, ...]\n * @param {Uint8Array} edges\n * @param {number} width\n * @param {number} height\n * @param {number} rho_resolution\n * @param {number} theta_resolution\n * @param {number} threshold\n * @param {number} min_line_length\n * @param {number} max_line_gap\n * @param {number} max_lines\n * @returns {Float32Array}\n */\nexport function hough_lines_p(edges, width, height, rho_resolution, theta_resolution, threshold, min_line_length, max_line_gap, max_lines) {\n    const ptr0 = passArray8ToWasm0(edges, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.hough_lines_p(ptr0, len0, width, height, rho_resolution, theta_resolution, threshold, min_line_length, max_line_gap, max_lines);\n    var v2 = getArrayF32FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n    return v2;\n}\n\n/**\n * Standard Hough Line Transform\n * Returns flattened array: [rho0, theta0, votes0, rho1, theta1, votes1, ...]\n * @param {Uint8Array} edges\n * @param {number} width\n * @param {number} height\n * @param {number} rho_resolution\n * @param {number} theta_resolution\n * @param {number} threshold\n * @param {number} max_lines\n * @returns {Float32Array}\n */\nexport function hough_lines(edges, width, height, rho_resolution, theta_resolution, threshold, max_lines) {\n    const ptr0 = passArray8ToWasm0(edges, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.hough_lines(ptr0, len0, width, height, rho_resolution, theta_resolution, threshold, max_lines);\n    var v2 = getArrayF32FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n    return v2;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);\n}\n/**\n * Morphological opening (erosion followed by dilation)\n * Removes small bright spots (noise) while preserving shape\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} kernel_size\n * @param {number} element_type\n * @returns {Uint8Array}\n */\nexport function morphological_open(input, width, height, kernel_size, element_type) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.morphological_open(ptr0, len0, width, height, kernel_size, element_type);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Top-hat transform (original - opening)\n * Extracts bright features smaller than the structuring element\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} kernel_size\n * @param {number} element_type\n * @returns {Uint8Array}\n */\nexport function top_hat(input, width, height, kernel_size, element_type) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.top_hat(ptr0, len0, width, height, kernel_size, element_type);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Hit-or-miss transform for detecting specific patterns\n * Useful for finding corners and line endpoints\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {Uint8Array} hit_element\n * @param {Uint8Array} miss_element\n * @param {number} elem_size\n * @returns {Uint8Array}\n */\nexport function hit_or_miss(input, width, height, hit_element, miss_element, elem_size) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ptr1 = passArray8ToWasm0(hit_element, wasm.__wbindgen_malloc);\n    const len1 = WASM_VECTOR_LEN;\n    const ptr2 = passArray8ToWasm0(miss_element, wasm.__wbindgen_malloc);\n    const len2 = WASM_VECTOR_LEN;\n    const ret = wasm.hit_or_miss(ptr0, len0, width, height, ptr1, len1, ptr2, len2, elem_size);\n    var v4 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v4;\n}\n\n/**\n * Close gaps in edge lines\n * Specialized for document edge enhancement\n * @param {Uint8Array} edges\n * @param {number} width\n * @param {number} height\n * @param {number} gap_size\n * @returns {Uint8Array}\n */\nexport function close_edge_gaps(edges, width, height, gap_size) {\n    const ptr0 = passArray8ToWasm0(edges, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.close_edge_gaps(ptr0, len0, width, height, gap_size);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Morphological closing (dilation followed by erosion)\n * Fills small dark holes while preserving shape\n * Excellent for closing gaps in document edges\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} kernel_size\n * @param {number} element_type\n * @returns {Uint8Array}\n */\nexport function morphological_close(input, width, height, kernel_size, element_type) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.morphological_close(ptr0, len0, width, height, kernel_size, element_type);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Remove small connected components (noise)\n * Keeps only components larger than min_area\n * @param {Uint8Array} binary\n * @param {number} width\n * @param {number} height\n * @param {number} min_area\n * @returns {Uint8Array}\n */\nexport function remove_small_components(binary, width, height, min_area) {\n    const ptr0 = passArray8ToWasm0(binary, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.remove_small_components(ptr0, len0, width, height, min_area);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Morphological gradient (dilation - erosion)\n * Highlights edges\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} kernel_size\n * @param {number} element_type\n * @returns {Uint8Array}\n */\nexport function morphological_gradient(input, width, height, kernel_size, element_type) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.morphological_gradient(ptr0, len0, width, height, kernel_size, element_type);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Thin edges to single pixel width\n * Uses Zhang-Suen thinning algorithm\n * @param {Uint8Array} binary\n * @param {number} width\n * @param {number} height\n * @returns {Uint8Array}\n */\nexport function thin_edges(binary, width, height) {\n    const ptr0 = passArray8ToWasm0(binary, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.thin_edges(ptr0, len0, width, height);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Black-hat transform (closing - original)\n * Extracts dark features smaller than the structuring element\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} kernel_size\n * @param {number} element_type\n * @returns {Uint8Array}\n */\nexport function black_hat(input, width, height, kernel_size, element_type) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.black_hat(ptr0, len0, width, height, kernel_size, element_type);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Erosion operation\n * Each pixel becomes the minimum of its neighborhood defined by the structuring element\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} kernel_size\n * @param {number} element_type\n * @returns {Uint8Array}\n */\nexport function erode(input, width, height, kernel_size, element_type) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.erode(ptr0, len0, width, height, kernel_size, element_type);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Skeletonization using morphological operations\n * Useful for finding the central line of thick edges\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} max_iterations\n * @returns {Uint8Array}\n */\nexport function skeletonize(input, width, height, max_iterations) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.skeletonize(ptr0, len0, width, height, max_iterations);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Dilation operation (enhanced version of existing)\n * Each pixel becomes the maximum of its neighborhood\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} kernel_size\n * @param {number} element_type\n * @returns {Uint8Array}\n */\nexport function dilate_enhanced(input, width, height, kernel_size, element_type) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.dilate_enhanced(ptr0, len0, width, height, kernel_size, element_type);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Niblack's adaptive thresholding\n * T(x,y) = mean(x,y) + k * stddev(x,y)\n * k is typically -0.2 for document images\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} block_size\n * @param {number} k\n * @returns {Uint8Array}\n */\nexport function adaptive_threshold_niblack(input, width, height, block_size, k) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.adaptive_threshold_niblack(ptr0, len0, width, height, block_size, k);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Sauvola's adaptive thresholding - excellent for document images\n * T(x,y) = mean(x,y) * (1 + k * (stddev(x,y) / R - 1))\n * where R is the dynamic range of standard deviation (128 for 8-bit images)\n * k is typically 0.5 for document images\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} block_size\n * @param {number} k\n * @param {number} r\n * @returns {Uint8Array}\n */\nexport function adaptive_threshold_sauvola(input, width, height, block_size, k, r) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.adaptive_threshold_sauvola(ptr0, len0, width, height, block_size, k, r);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Adaptive Gaussian-weighted mean thresholding (similar to OpenCV's ADAPTIVE_THRESH_GAUSSIAN_C)\n * Weights decrease with distance from center pixel\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} block_size\n * @param {number} c\n * @returns {Uint8Array}\n */\nexport function adaptive_threshold_gaussian(input, width, height, block_size, c) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.adaptive_threshold_gaussian(ptr0, len0, width, height, block_size, c);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\nlet cachedUint32ArrayMemory0 = null;\n\nfunction getUint32ArrayMemory0() {\n    if (cachedUint32ArrayMemory0 === null || cachedUint32ArrayMemory0.byteLength === 0) {\n        cachedUint32ArrayMemory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachedUint32ArrayMemory0;\n}\n\nfunction getArrayU32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint32ArrayMemory0().subarray(ptr / 4, ptr / 4 + len);\n}\n/**\n * Adaptive thresholding methods\n * These automatically determine thresholds based on local image statistics,\n * which is crucial for documents with uneven lighting.\n * Calculate integral image for efficient local statistics computation\n * This allows O(1) computation of any rectangular sum\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @returns {Uint32Array}\n */\nexport function compute_integral_image(input, width, height) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.compute_integral_image(ptr0, len0, width, height);\n    var v2 = getArrayU32FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n    return v2;\n}\n\n/**\n * Adaptive mean thresholding (similar to OpenCV's ADAPTIVE_THRESH_MEAN_C)\n * For each pixel, threshold is the mean of block_size x block_size neighborhood minus C\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} block_size\n * @param {number} c\n * @returns {Uint8Array}\n */\nexport function adaptive_threshold_mean(input, width, height, block_size, c) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.adaptive_threshold_mean(ptr0, len0, width, height, block_size, c);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Multi-level Otsu thresholding for images with multiple intensity regions\n * Returns multiple thresholds for separating different regions\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} levels\n * @returns {Uint8Array}\n */\nexport function multi_otsu_threshold(input, width, height, levels) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.multi_otsu_threshold(ptr0, len0, width, height, levels);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Compute adaptive Canny thresholds based on image statistics\n * Returns (low_threshold, high_threshold) computed from gradient magnitude histogram\n * @param {Float32Array} magnitude\n * @param {number} _width\n * @param {number} _height\n * @param {number} low_ratio\n * @param {number} high_ratio\n * @returns {Float32Array}\n */\nexport function compute_adaptive_canny_thresholds(magnitude, _width, _height, low_ratio, high_ratio) {\n    const ptr0 = passArrayF32ToWasm0(magnitude, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.compute_adaptive_canny_thresholds(ptr0, len0, _width, _height, low_ratio, high_ratio);\n    var v2 = getArrayF32FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n    return v2;\n}\n\n/**\n * Otsu's method for automatic threshold selection\n * Returns the optimal threshold that minimizes intra-class variance\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @returns {number}\n */\nexport function otsu_threshold(input, width, height) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.otsu_threshold(ptr0, len0, width, height);\n    return ret;\n}\n\n/**\n * CLAHE - Contrast Limited Adaptive Histogram Equalization\n *\n * Parameters:\n * - input: grayscale image\n * - width, height: image dimensions\n * - tile_grid_x, tile_grid_y: number of tiles in x and y directions (typically 8x8)\n * - clip_limit: contrast limit (1.0 = no clipping, 2.0-4.0 typical for documents)\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} tile_grid_x\n * @param {number} tile_grid_y\n * @param {number} clip_limit\n * @returns {Uint8Array}\n */\nexport function clahe(input, width, height, tile_grid_x, tile_grid_y, clip_limit) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.clahe(ptr0, len0, width, height, tile_grid_x, tile_grid_y, clip_limit);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Simple contrast stretch (normalization)\n * Stretches histogram to use full 0-255 range\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @returns {Uint8Array}\n */\nexport function contrast_stretch(input, width, height) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.contrast_stretch(ptr0, len0, width, height);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Standard histogram equalization (global)\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @returns {Uint8Array}\n */\nexport function histogram_equalization(input, width, height) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.histogram_equalization(ptr0, len0, width, height);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Gamma correction for adjusting overall brightness\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} gamma\n * @returns {Uint8Array}\n */\nexport function gamma_correction(input, width, height, gamma) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.gamma_correction(ptr0, len0, width, height, gamma);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Illumination normalization using large-scale Gaussian\n * Removes low-frequency illumination variations\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} sigma\n * @returns {Uint8Array}\n */\nexport function illumination_normalize(input, width, height, sigma) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.illumination_normalize(ptr0, len0, width, height, sigma);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Combined preprocessing for document images\n * Applies: illumination normalization -> CLAHE -> contrast stretch\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} clahe_clip\n * @param {number} clahe_grid\n * @returns {Uint8Array}\n */\nexport function preprocess_document(input, width, height, clahe_clip, clahe_grid) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.preprocess_document(ptr0, len0, width, height, clahe_clip, clahe_grid);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Percentile-based contrast stretch\n * More robust to outliers than simple min-max stretch\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} low_percentile\n * @param {number} high_percentile\n * @returns {Uint8Array}\n */\nexport function percentile_contrast_stretch(input, width, height, low_percentile, high_percentile) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.percentile_contrast_stretch(ptr0, len0, width, height, low_percentile, high_percentile);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * @param {Uint8Array} grayscale\n * @param {number} width\n * @param {number} height\n * @param {number} kernel_size\n * @param {number} sigma\n * @returns {Uint8Array}\n */\nexport function blur(grayscale, width, height, kernel_size, sigma) {\n    const ptr0 = passArray8ToWasm0(grayscale, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.blur(ptr0, len0, width, height, kernel_size, sigma);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\nlet cachedUint16ArrayMemory0 = null;\n\nfunction getUint16ArrayMemory0() {\n    if (cachedUint16ArrayMemory0 === null || cachedUint16ArrayMemory0.byteLength === 0) {\n        cachedUint16ArrayMemory0 = new Uint16Array(wasm.memory.buffer);\n    }\n    return cachedUint16ArrayMemory0;\n}\n\nfunction passArray16ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 2, 2) >>> 0;\n    getUint16ArrayMemory0().set(arg, ptr / 2);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n * Refine corner positions using sub-pixel edge fitting\n * Uses gradient information to find precise edge locations\n * @param {Int16Array} gradients\n * @param {number} width\n * @param {number} height\n * @param {Float32Array} corners\n * @param {number} search_radius\n * @returns {Float32Array}\n */\nexport function refine_corners_subpixel(gradients, width, height, corners, search_radius) {\n    const ptr0 = passArray16ToWasm0(gradients, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ptr1 = passArrayF32ToWasm0(corners, wasm.__wbindgen_malloc);\n    const len1 = WASM_VECTOR_LEN;\n    const ret = wasm.refine_corners_subpixel(ptr0, len0, width, height, ptr1, len1, search_radius);\n    var v3 = getArrayF32FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n    return v3;\n}\n\n/**\n * Calculate size appropriateness score\n * Documents should occupy a reasonable portion of the frame\n * @param {Float32Array} corners\n * @param {number} image_width\n * @param {number} image_height\n * @param {number} min_coverage\n * @param {number} max_coverage\n * @param {number} ideal_coverage\n * @returns {number}\n */\nexport function calculate_size_score(corners, image_width, image_height, min_coverage, max_coverage, ideal_coverage) {\n    const ptr0 = passArrayF32ToWasm0(corners, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.calculate_size_score(ptr0, len0, image_width, image_height, min_coverage, max_coverage, ideal_coverage);\n    return ret;\n}\n\n/**\n * Validate corners represent a valid quadrilateral\n * @param {Float32Array} corners\n * @returns {Float32Array}\n */\nexport function validate_quadrilateral(corners) {\n    const ptr0 = passArrayF32ToWasm0(corners, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.validate_quadrilateral(ptr0, len0);\n    var v2 = getArrayF32FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n    return v2;\n}\n\n/**\n * Calculate overall document detection confidence\n * @param {number} edge_score\n * @param {number} shape_score\n * @param {number} aspect_score\n * @param {number} size_score\n * @returns {number}\n */\nexport function calculate_detection_confidence(edge_score, shape_score, aspect_score, size_score) {\n    const ret = wasm.calculate_detection_confidence(edge_score, shape_score, aspect_score, size_score);\n    return ret;\n}\n\n/**\n * Rank multiple document candidates and return the best ones\n * Input: flat array [corners0..., confidence0, corners1..., confidence1, ...]\n * Output: sorted array with same format, best first\n * @param {Float32Array} candidates\n * @param {number} max_candidates\n * @param {number} min_confidence\n * @returns {Float32Array}\n */\nexport function rank_document_candidates(candidates, max_candidates, min_confidence) {\n    const ptr0 = passArrayF32ToWasm0(candidates, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.rank_document_candidates(ptr0, len0, max_candidates, min_confidence);\n    var v2 = getArrayF32FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n    return v2;\n}\n\n/**\n * Calculate edge strength along quadrilateral edges\n * Uses gradient magnitude along the detected edges\n * @param {Int16Array} gradients\n * @param {number} width\n * @param {number} height\n * @param {Float32Array} corners\n * @param {number} sample_points\n * @returns {number}\n */\nexport function calculate_edge_strength(gradients, width, height, corners, sample_points) {\n    const ptr0 = passArray16ToWasm0(gradients, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ptr1 = passArrayF32ToWasm0(corners, wasm.__wbindgen_malloc);\n    const len1 = WASM_VECTOR_LEN;\n    const ret = wasm.calculate_edge_strength(ptr0, len0, width, height, ptr1, len1, sample_points);\n    return ret;\n}\n\nlet cachedInt16ArrayMemory0 = null;\n\nfunction getInt16ArrayMemory0() {\n    if (cachedInt16ArrayMemory0 === null || cachedInt16ArrayMemory0.byteLength === 0) {\n        cachedInt16ArrayMemory0 = new Int16Array(wasm.memory.buffer);\n    }\n    return cachedInt16ArrayMemory0;\n}\n\nfunction getArrayI16FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getInt16ArrayMemory0().subarray(ptr / 2, ptr / 2 + len);\n}\n/**\n * @param {Uint8Array} blurred\n * @param {number} width\n * @param {number} height\n * @returns {Int16Array}\n */\nexport function calculate_gradients(blurred, width, height) {\n    const ptr0 = passArray8ToWasm0(blurred, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.calculate_gradients(ptr0, len0, width, height);\n    var v2 = getArrayI16FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 2, 2);\n    return v2;\n}\n\n/**\n * @param {Int16Array} dx\n * @param {Int16Array} dy\n * @param {number} width\n * @param {number} height\n * @param {boolean} l2_gradient\n * @returns {Float32Array}\n */\nexport function non_maximum_suppression(dx, dy, width, height, l2_gradient) {\n    const ptr0 = passArray16ToWasm0(dx, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ptr1 = passArray16ToWasm0(dy, wasm.__wbindgen_malloc);\n    const len1 = WASM_VECTOR_LEN;\n    const ret = wasm.non_maximum_suppression(ptr0, len0, ptr1, len1, width, height, l2_gradient);\n    var v3 = getArrayF32FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n    return v3;\n}\n\n/**\n * @param {Uint8Array} edges\n * @param {number} width\n * @param {number} height\n * @param {number} kernel_size\n * @returns {Uint8Array}\n */\nexport function dilate(edges, width, height, kernel_size) {\n    const ptr0 = passArray8ToWasm0(edges, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.dilate(ptr0, len0, width, height, kernel_size);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Enhanced non-maximum suppression using precise gradient direction\n * This provides better edge localization than the binned direction approach\n * @param {Float32Array} magnitude\n * @param {Float32Array} direction\n * @param {number} width\n * @param {number} height\n * @returns {Float32Array}\n */\nexport function nms_precise(magnitude, direction, width, height) {\n    const ptr0 = passArrayF32ToWasm0(magnitude, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ptr1 = passArrayF32ToWasm0(direction, wasm.__wbindgen_malloc);\n    const len1 = WASM_VECTOR_LEN;\n    const ret = wasm.nms_precise(ptr0, len0, ptr1, len1, width, height);\n    var v3 = getArrayF32FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n    return v3;\n}\n\n/**\n * Calculate Sobel gradients using 3x3 kernel\n * Returns interleaved [gx0, gy0, gx1, gy1, ...] as i16 values\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @returns {Int16Array}\n */\nexport function sobel_gradients_3x3(input, width, height) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.sobel_gradients_3x3(ptr0, len0, width, height);\n    var v2 = getArrayI16FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 2, 2);\n    return v2;\n}\n\n/**\n * Calculate Sobel gradients with SIMD optimization\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @returns {Int16Array}\n */\nexport function sobel_gradients_3x3_simd(input, width, height) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.sobel_gradients_3x3_simd(ptr0, len0, width, height);\n    var v2 = getArrayI16FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 2, 2);\n    return v2;\n}\n\n/**\n * Compute edge direction map for document detection\n * Returns direction in degrees [0, 180) for each pixel\n * @param {Int16Array} gradients\n * @param {number} width\n * @param {number} height\n * @returns {Uint8Array}\n */\nexport function edge_direction_map(gradients, width, height) {\n    const ptr0 = passArray16ToWasm0(gradients, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.edge_direction_map(ptr0, len0, width, height);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Calculate Sobel 5x5 gradients for more robust edge detection\n * Larger kernel provides better noise immunity but slightly more blur\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @returns {Int16Array}\n */\nexport function sobel_gradients_5x5(input, width, height) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.sobel_gradients_5x5(ptr0, len0, width, height);\n    var v2 = getArrayI16FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 2, 2);\n    return v2;\n}\n\n/**\n * Compute gradient magnitude and direction\n * Returns: [magnitude_0, direction_0, magnitude_1, direction_1, ...]\n * Direction is quantized to 0-7 representing 8 directions (0, 22.5, 45, ... 157.5)\n * @param {Int16Array} gradients\n * @param {number} width\n * @param {number} height\n * @param {boolean} l2_norm\n * @returns {Float32Array}\n */\nexport function gradient_magnitude_direction(gradients, width, height, l2_norm) {\n    const ptr0 = passArray16ToWasm0(gradients, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.gradient_magnitude_direction(ptr0, len0, width, height, l2_norm);\n    var v2 = getArrayF32FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n    return v2;\n}\n\n/**\n * Calculate Scharr gradients using 3x3 kernel (better accuracy than Sobel)\n * Returns interleaved [gx0, gy0, gx1, gy1, ...] as i16 values\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @returns {Int16Array}\n */\nexport function scharr_gradients_3x3(input, width, height) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.scharr_gradients_3x3(ptr0, len0, width, height);\n    var v2 = getArrayI16FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 2, 2);\n    return v2;\n}\n\n/**\n * Applies double thresholding and hysteresis using a stack-based approach.\n * Optimized version with SIMD for threshold comparisons and better memory access patterns.\n * Follows OpenCV's logic more closely.\n *\n * # Arguments\n * * `suppressed` - Suppressed magnitude values (Float32Array from JavaScript)\n * * `width` - Image width\n * * `height` - Image height\n * * `low_threshold` - Low threshold value\n * * `high_threshold` - High threshold value\n *\n * # Returns\n * Edge map as Vec<u8> (0: weak edge/potential, 1: non-edge, 2: strong edge)\n * @param {Float32Array} suppressed\n * @param {number} width\n * @param {number} height\n * @param {number} low_threshold\n * @param {number} high_threshold\n * @returns {Uint8Array}\n */\nexport function hysteresis_thresholding(suppressed, width, height, low_threshold, high_threshold) {\n    const ptr0 = passArrayF32ToWasm0(suppressed, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.hysteresis_thresholding(ptr0, len0, width, height, low_threshold, high_threshold);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Combined hysteresis thresholding and binary conversion\n * This is a convenience function that combines both steps for efficiency\n * Optimized to avoid intermediate allocations where possible\n *\n * # Arguments\n * * `suppressed` - Suppressed magnitude values (Float32Array from JavaScript)\n * * `width` - Image width\n * * `height` - Image height\n * * `low_threshold` - Low threshold value\n * * `high_threshold` - High threshold value\n *\n * # Returns\n * Binary edge image as Vec<u8> (0 or 255)\n * @param {Float32Array} suppressed\n * @param {number} width\n * @param {number} height\n * @param {number} low_threshold\n * @param {number} high_threshold\n * @returns {Uint8Array}\n */\nexport function hysteresis_thresholding_binary(suppressed, width, height, low_threshold, high_threshold) {\n    const ptr0 = passArrayF32ToWasm0(suppressed, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.hysteresis_thresholding_binary(ptr0, len0, width, height, low_threshold, high_threshold);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Creates a binary edge image from the hysteresis edge map\n * SIMD-optimized version for converting edge map to binary\n *\n * # Arguments\n * * `edge_map` - Edge map from hysteresis thresholding (0, 1, 2 values)\n *\n * # Returns\n * Binary edge image as Vec<u8> (0 or 255)\n * @param {Uint8Array} edge_map\n * @returns {Uint8Array}\n */\nexport function edge_map_to_binary(edge_map) {\n    const ptr0 = passArray8ToWasm0(edge_map, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.edge_map_to_binary(ptr0, len0);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * @param {Uint8Array} grayscale\n * @param {number} width\n * @param {number} height\n * @param {number} low_threshold\n * @param {number} high_threshold\n * @param {number} kernel_size\n * @param {number} sigma\n * @param {boolean} l2_gradient\n * @param {boolean} apply_dilation\n * @param {number} dilation_kernel_size\n * @returns {Uint8Array}\n */\nexport function canny_edge_detector_full(grayscale, width, height, low_threshold, high_threshold, kernel_size, sigma, l2_gradient, apply_dilation, dilation_kernel_size) {\n    const ptr0 = passArray8ToWasm0(grayscale, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.canny_edge_detector_full(ptr0, len0, width, height, low_threshold, high_threshold, kernel_size, sigma, l2_gradient, apply_dilation, dilation_kernel_size);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbindgen_init_externref_table = function() {\n        const table = wasm.__wbindgen_export_0;\n        const offset = table.grow(4);\n        table.set(0, undefined);\n        table.set(offset + 0, undefined);\n        table.set(offset + 1, null);\n        table.set(offset + 2, true);\n        table.set(offset + 3, false);\n        ;\n    };\n\n    return imports;\n}\n\nfunction __wbg_init_memory(imports, memory) {\n\n}\n\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedFloat32ArrayMemory0 = null;\n    cachedInt16ArrayMemory0 = null;\n    cachedUint16ArrayMemory0 = null;\n    cachedUint32ArrayMemory0 = null;\n    cachedUint8ArrayMemory0 = null;\n\n\n    wasm.__wbindgen_start();\n    return wasm;\n}\n\nfunction initSync(module) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module !== 'undefined') {\n        if (Object.getPrototypeOf(module) === Object.prototype) {\n            ({module} = module)\n        } else {\n            console.warn('using deprecated parameters for `initSync()`; pass a single object instead')\n        }\n    }\n\n    const imports = __wbg_get_imports();\n\n    __wbg_init_memory(imports);\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(module_or_path) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module_or_path !== 'undefined') {\n        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n            ({module_or_path} = module_or_path)\n        } else {\n            console.warn('using deprecated parameters for the initialization function; pass a single object instead')\n        }\n    }\n\n    if (typeof module_or_path === 'undefined') {\n        module_or_path = new URL('wasm_blur_bg.wasm', import.meta.url);\n    }\n    const imports = __wbg_get_imports();\n\n    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {\n        module_or_path = fetch(module_or_path);\n    }\n\n    __wbg_init_memory(imports);\n\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nexport { initSync };\nexport default __wbg_init;\n","/**\r\n * Pure JavaScript implementation of edge detection algorithms\r\n * Inspired by OpenCV's Canny edge detector\r\n */\r\n\r\nimport { DEFAULTS } from './constants.js';\r\nimport init, { \r\n  blur as wasmBlur, \r\n  calculate_gradients as wasmGradients, \r\n  dilate as wasmDilate, \r\n  non_maximum_suppression as wasmMaximumSuppression, \r\n  canny_edge_detector_full as wasmFullCanny,\r\n  hysteresis_thresholding as wasmHysteresis,\r\n  hysteresis_thresholding_binary as wasmHysteresisBinary\r\n} from '../wasm_blur/pkg/wasm_blur.js';\r\n\r\n// Initialize the wasm module\r\nconst wasmReady = init();\r\n\r\n/**\r\n * Converts ImageData to grayscale (separate from blur for consistency with jscanify)\r\n * @param {ImageData} imageData - Original image data\r\n * @returns {Uint8ClampedArray} Grayscale image data (1 channel)\r\n */\r\nexport function convertToGrayscale(imageData) {\r\n  const { width, height, data } = imageData;\r\n  const grayscale = new Uint8ClampedArray(width * height);\r\n  \r\n  // Convert to grayscale with integer math (faster than floating point)\r\n  // Use bit shifting for multiplication (>>8 is equivalent to /256)\r\n  for (let i = 0, j = 0; i < data.length; i += 4, j++) {\r\n    // 54 (~0.2126*256), 183 (~0.7152*256), 19 (~0.0722*256)\r\n    grayscale[j] = (data[i] * 54 + data[i+1] * 183 + data[i+2] * 19) >> 8;\r\n  }\r\n  \r\n  return grayscale;\r\n}\r\n\r\n/**\r\n * Applies Gaussian blur to a grayscale image (matching jscanify's approach)\r\n * @param {Uint8ClampedArray} grayscale - Grayscale image data\r\n * @param {number} width - Image width\r\n * @param {number} height - Image height\r\n * @param {number} kernelSize - Kernel size (should be 5 to match jscanify)\r\n * @param {number} sigma - Gaussian sigma parameter\r\n * @returns {Uint8ClampedArray} Blurred grayscale image data\r\n */\r\nexport function gaussianBlurGrayscale(grayscale, width, height, kernelSize = 5, sigma = 0) {\r\n  // If sigma is 0, calculate it from kernel size (OpenCV default)\r\n  if (sigma === 0) {\r\n    sigma = 0.3 * ((kernelSize - 1) * 0.5 - 1) + 0.8;\r\n  }\r\n  \r\n  const halfKernel = Math.floor(kernelSize / 2);\r\n  \r\n  // Create and normalize Gaussian kernel once\r\n  const kernel = createGaussianKernel(kernelSize, sigma);\r\n  \r\n  // Preallocate arrays\r\n  const tempArray = new Uint8ClampedArray(width * height);\r\n  const blurred = new Uint8ClampedArray(width * height);\r\n  \r\n  // Horizontal pass - process rows in a single loop to improve cache locality\r\n  for (let y = 0; y < height; y++) {\r\n    const rowOffset = y * width;\r\n    \r\n    for (let x = 0; x < width; x++) {\r\n      let sum = 0;\r\n      \r\n      // Apply kernel horizontally with bounds checking\r\n      for (let k = -halfKernel; k <= halfKernel; k++) {\r\n        const xOffset = Math.min(width - 1, Math.max(0, x + k));\r\n        sum += grayscale[rowOffset + xOffset] * kernel[halfKernel + k];\r\n      }\r\n      \r\n      tempArray[rowOffset + x] = sum;\r\n    }\r\n  }\r\n  \r\n  // Vertical pass - process columns with better memory access pattern\r\n  for (let x = 0; x < width; x++) {\r\n    for (let y = 0; y < height; y++) {\r\n      let sum = 0;\r\n      \r\n      // Apply kernel vertically with bounds checking\r\n      for (let k = -halfKernel; k <= halfKernel; k++) {\r\n        const yOffset = Math.min(height - 1, Math.max(0, y + k));\r\n        sum += tempArray[yOffset * width + x] * kernel[halfKernel + k];\r\n      }\r\n      \r\n      blurred[y * width + x] = Math.round(sum);\r\n    }\r\n  }\r\n  \r\n  return blurred;\r\n}\r\n\r\n/**\r\n * Legacy wrapper for backwards compatibility\r\n * @param {ImageData} imageData - Original image data\r\n * @param {number} sigma - Gaussian sigma parameter (standard deviation)\r\n * @returns {Uint8ClampedArray} Blurred grayscale image data (1 channel)\r\n */\r\nexport function gaussianBlur(imageData, sigma = DEFAULTS.GAUSSIAN_SIGMA, forcedKernelSize = null) {\r\n  const grayscale = convertToGrayscale(imageData);\r\n  const kernelSize = forcedKernelSize || 5; // Default to 5 like jscanify\r\n  return gaussianBlurGrayscale(grayscale, imageData.width, imageData.height, kernelSize, sigma);\r\n}\r\n\r\n/**\r\n * Creates a 1D Gaussian kernel\r\n * @param {number} size - Kernel size (odd number)\r\n * @param {number} sigma - Gaussian sigma parameter\r\n * @returns {Float32Array} Gaussian kernel\r\n */\r\nfunction createGaussianKernel(size, sigma) {\r\n  const kernel = new Float32Array(size);\r\n  const halfSize = Math.floor(size / 2);\r\n  \r\n  let sum = 0;\r\n  for (let i = 0; i < size; i++) {\r\n    const x = i - halfSize;\r\n    // Gaussian function: (1/(sigma*sqrt(2*PI))) * e^(-(x^2)/(2*sigma^2))\r\n    kernel[i] = Math.exp(-(x * x) / (2 * sigma * sigma));\r\n    sum += kernel[i];\r\n  }\r\n  \r\n  // Normalize kernel\r\n  for (let i = 0; i < size; i++) {\r\n    kernel[i] /= sum;\r\n  }\r\n  \r\n  return kernel;\r\n}\r\n\r\n/**\r\n * Calculates the gradients (dx, dy) using Sobel operators\r\n * @param {Uint8ClampedArray} blurred - Blurred grayscale image\r\n * @param {number} width - Image width\r\n * @param {number} height - Image height\r\n * @returns {{dx: Int16Array, dy: Int16Array}} Object containing gradient arrays\r\n */\r\nfunction calculateGradients(blurred, width, height) {\r\n  // Use Int16Array to store gradients, allowing negative values\r\n  const dx = new Int16Array(width * height);\r\n  const dy = new Int16Array(width * height);\r\n  \r\n  // Find gradients by unrolling the Sobel operator loops\r\n  for (let y = 1; y < height - 1; y++) {\r\n    const rowOffset = y * width;\r\n    const prevRowOffset = (y - 1) * width;\r\n    const nextRowOffset = (y + 1) * width;\r\n\r\n    for (let x = 1; x < width - 1; x++) {\r\n      const currentIdx = rowOffset + x;\r\n\r\n      // Get neighborhood pixels\r\n      const p0 = blurred[prevRowOffset + x - 1];\r\n      const p1 = blurred[prevRowOffset + x];\r\n      const p2 = blurred[prevRowOffset + x + 1];\r\n      const p3 = blurred[rowOffset + x - 1];\r\n      const p5 = blurred[rowOffset + x + 1];\r\n      const p6 = blurred[nextRowOffset + x - 1];\r\n      const p7 = blurred[nextRowOffset + x];\r\n      const p8 = blurred[nextRowOffset + x + 1];\r\n      \r\n      // Calculate Sobel gradients\r\n      const gx = (p2 - p0) + 2 * (p5 - p3) + (p8 - p6);\r\n      const gy = (p6 + 2 * p7 + p8) - (p0 + 2 * p1 + p2);\r\n      \r\n      dx[currentIdx] = gx;\r\n      dy[currentIdx] = gy;\r\n    }\r\n  }\r\n  \r\n  return { dx, dy };\r\n}\r\n\r\n\r\n/**\r\n * Applies non-maximum suppression to the gradient magnitude\r\n * @param {Int16Array} dx - Gradient in x-direction\r\n * @param {Int16Array} dy - Gradient in y-direction\r\n * @param {number} width - Image width\r\n * @param {number} height - Image height\r\n * @param {boolean} L2gradient - Whether to use L2 norm for magnitude\r\n * @returns {Float32Array} Suppressed magnitude (using Float32 for precision)\r\n */\r\nfunction nonMaximumSuppression(dx, dy, width, height, L2gradient) {\r\n  // Use Float32Array for magnitude to preserve precision before thresholding\r\n  const magnitude = new Float32Array(width * height);\r\n  const suppressed = new Float32Array(width * height);\r\n  \r\n  // Calculate magnitude for all pixels first\r\n  for (let i = 0; i < dx.length; i++) {\r\n    const gx = dx[i];\r\n    const gy = dy[i];\r\n    if (L2gradient) {\r\n      magnitude[i] = Math.sqrt(gx * gx + gy * gy);\r\n    } else {\r\n      magnitude[i] = Math.abs(gx) + Math.abs(gy); // L1 norm\r\n    }\r\n  }\r\n  \r\n  // Perform non-maximum suppression\r\n  for (let y = 1; y < height - 1; y++) {\r\n    for (let x = 1; x < width - 1; x++) {\r\n      const idx = y * width + x;\r\n      const mag = magnitude[idx];\r\n      \r\n      // Skip pixels with zero magnitude\r\n      if (mag === 0) {\r\n        suppressed[idx] = 0;\r\n        continue;\r\n      }\r\n      \r\n      const gx = dx[idx];\r\n      const gy = dy[idx];\r\n      \r\n      let neighbor1 = 0, neighbor2 = 0;\r\n      \r\n      // Determine neighbors based on gradient direction\r\n      // Use absolute values to determine dominant direction\r\n      const absGx = Math.abs(gx);\r\n      const absGy = Math.abs(gy);\r\n      \r\n      if (absGy > absGx * 2.4142) { // Vertical edge (angle near 90 or 270)\r\n        neighbor1 = magnitude[idx - width]; // top\r\n        neighbor2 = magnitude[idx + width]; // bottom\r\n      } else if (absGx > absGy * 2.4142) { // Horizontal edge (angle near 0 or 180)\r\n        neighbor1 = magnitude[idx - 1]; // left\r\n        neighbor2 = magnitude[idx + 1]; // right\r\n      } else { // Diagonal edge\r\n        // Determine diagonal direction based on signs of gx and gy\r\n        const s = (gx ^ gy) < 0 ? -1 : 1; // Check if signs are different\r\n        if (gy > 0) { // Gradient points down\r\n          neighbor1 = magnitude[(y - 1) * width + (x - s)]; // top-left/right\r\n          neighbor2 = magnitude[(y + 1) * width + (x + s)]; // bottom-right/left\r\n        } else { // Gradient points up\r\n          neighbor1 = magnitude[(y + 1) * width + (x - s)]; // bottom-left/right\r\n          neighbor2 = magnitude[(y - 1) * width + (x + s)]; // top-right/left\r\n        }\r\n        // Refined diagonal check (approximating OpenCV's logic)\r\n        // Check 45 degrees (top-right / bottom-left)\r\n        if ((gx > 0 && gy > 0) || (gx < 0 && gy < 0)) { // Quadrants 1 & 3\r\n             neighbor1 = magnitude[(y - 1) * width + (x + 1)]; // top-right\r\n             neighbor2 = magnitude[(y + 1) * width + (x - 1)]; // bottom-left\r\n        } else { // Quadrants 2 & 4 (135 degrees)\r\n             neighbor1 = magnitude[(y - 1) * width + (x - 1)]; // top-left\r\n             neighbor2 = magnitude[(y + 1) * width + (x + 1)]; // bottom-right\r\n        }\r\n      }\r\n      \r\n      // If the pixel's magnitude is greater than or equal to its neighbors\r\n      // along the gradient direction, keep it. Otherwise, suppress it.\r\n      if (mag >= neighbor1 && mag >= neighbor2) {\r\n        suppressed[idx] = mag;\r\n      } else {\r\n        suppressed[idx] = 0;\r\n      }\r\n    }\r\n  }\r\n  return suppressed;\r\n}\r\n\r\n\r\n/**\r\n * Applies double thresholding and hysteresis using a stack-based approach.\r\n * Follows OpenCV's logic more closely.\r\n * @param {Float32Array} suppressed - Suppressed magnitude (Float32Array)\r\n * @param {number} width - Image width\r\n * @param {number} height - Image height\r\n * @param {number} lowThreshold - Low threshold value\r\n * @param {number} highThreshold - High threshold value\r\n * @returns {Uint8Array} Edge map (0: non-edge, 2: edge pixel)\r\n */\r\nfunction hysteresisThresholding(suppressed, width, height, lowThreshold, highThreshold) {\r\n  // Map values: 0 = weak edge (potential), 1 = non-edge, 2 = strong edge\r\n  const edgeMap = new Uint8Array(width * height);\r\n  const stack = [];\r\n  \r\n  // First pass: Identify strong edges and potential weak edges\r\n  for (let y = 1; y < height - 1; y++) { // Iterate excluding borders\r\n    for (let x = 1; x < width - 1; x++) {\r\n      const idx = y * width + x;\r\n      const mag = suppressed[idx];\r\n      \r\n      if (mag >= highThreshold) {\r\n        // Strong edge pixel\r\n        edgeMap[idx] = 2;\r\n        stack.push({ x, y });\r\n      } else if (mag >= lowThreshold) {\r\n        // Weak edge pixel (potential edge)\r\n        edgeMap[idx] = 0; // Mark as potential\r\n      } else {\r\n        // Non-edge pixel\r\n        edgeMap[idx] = 1; // Mark as non-edge\r\n      }\r\n    }\r\n  }\r\n  // Initialize borders as non-edge (value 1)\r\n   for (let x = 0; x < width; x++) {\r\n       edgeMap[x] = 1; // Top row\r\n       edgeMap[(height - 1) * width + x] = 1; // Bottom row\r\n   }\r\n   for (let y = 1; y < height - 1; y++) {\r\n       edgeMap[y * width] = 1; // Left column\r\n       edgeMap[y * width + width - 1] = 1; // Right column\r\n   }\r\n\r\n\r\n  // Second pass: Hysteresis - connect weak edges to strong edges\r\n  const dxNeighbors = [-1, 0, 1, -1, 1, -1, 0, 1];\r\n  const dyNeighbors = [-1, -1, -1, 0, 0, 1, 1, 1];\r\n  \r\n  while (stack.length > 0) {\r\n    const { x, y } = stack.pop();\r\n    \r\n    // Check all 8 neighbors\r\n    for (let i = 0; i < 8; i++) {\r\n      const nx = x + dxNeighbors[i];\r\n      const ny = y + dyNeighbors[i];\r\n      const nidx = ny * width + nx;\r\n      \r\n      // Check bounds (already handled by border initialization)\r\n      // If neighbor is a weak edge (value 0), promote it to strong (value 2) and add to stack\r\n      if (edgeMap[nidx] === 0) {\r\n        edgeMap[nidx] = 2; // Promote to strong edge\r\n        stack.push({ x: nx, y: ny });\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Note: Pixels that were initially weak (0) but not connected remain 0.\r\n  // Pixels below lowThreshold remain 1. Only pixels marked 2 are considered final edges.\r\n  \r\n  return edgeMap; // Return the map with 0, 1, 2 values\r\n}\r\n\r\n/**\r\n * Applies morphological dilation to binary image using a separable (two-pass) approach.\r\n * This is much faster than a 2D kernel for square structuring elements.\r\n * @param {Uint8ClampedArray} edges - Binary edge image (0 or 255)\r\n * @param {number} width - Image width\r\n * @param {number} height - Image height\r\n * @param {number} kernelSize - Kernel size (default 5 to match jscanify)\r\n * @returns {Uint8ClampedArray} Dilated edge image\r\n */\r\nexport function dilateEdges(edges, width, height, kernelSize = 5) {\r\n  const halfKernel = Math.floor(kernelSize / 2);\r\n  const temp = new Uint8ClampedArray(width * height);\r\n  const dilated = new Uint8ClampedArray(width * height);\r\n\r\n  // Horizontal pass\r\n  for (let y = 0; y < height; y++) {\r\n    const rowOffset = y * width;\r\n    for (let x = 0; x < width; x++) {\r\n      let maxVal = 0;\r\n      // Find max in horizontal neighborhood\r\n      for (let k = -halfKernel; k <= halfKernel; k++) {\r\n        const nx = x + k;\r\n        if (nx >= 0 && nx < width) {\r\n          const val = edges[rowOffset + nx];\r\n          if (val > maxVal) {\r\n            maxVal = val;\r\n          }\r\n        }\r\n      }\r\n      temp[rowOffset + x] = maxVal;\r\n    }\r\n  }\r\n\r\n  // Vertical pass\r\n  for (let x = 0; x < width; x++) {\r\n    for (let y = 0; y < height; y++) {\r\n      let maxVal = 0;\r\n      // Find max in vertical neighborhood from temp array\r\n      for (let k = -halfKernel; k <= halfKernel; k++) {\r\n        const ny = y + k;\r\n        if (ny >= 0 && ny < height) {\r\n          const val = temp[ny * width + x];\r\n          if (val > maxVal) {\r\n            maxVal = val;\r\n          }\r\n        }\r\n      }\r\n      dilated[y * width + x] = maxVal;\r\n    }\r\n  }\r\n  \r\n  return dilated;\r\n}\r\n\r\n/**\r\n * Full Canny edge detector implementation matching jscanify's approach\r\n * @param {ImageData} imageData - Original image data\r\n * @param {Object} options - Configuration options\r\n * @param {number} [options.lowThreshold=75] - Low threshold for hysteresis (matching jscanify)\r\n * @param {number} [options.highThreshold=200] - High threshold for hysteresis (matching jscanify)\r\n * @param {number} [options.sigma=0] - Gaussian blur sigma (0 means auto-calculate from kernel size)\r\n * @param {number} [options.kernelSize=5] - Gaussian kernel size (matching jscanify)\r\n * @param {boolean} [options.L2gradient=false] - Use L2 norm for gradient magnitude (like OpenCV default)\r\n * @param {boolean} [options.applyDilation=true] - Apply dilation after Canny (matching jscanify)\r\n * @param {number} [options.dilationKernelSize=5] - Dilation kernel size\r\n * @param {boolean} [options.useWasmBlur=false] - Use WASM for Gaussian blur\r\n * @param {boolean} [options.useWasmGradients=false] - Use WASM for gradient calculation\r\n * @param {boolean} [options.useWasmDilation=false] - Use WASM for dilation\r\n * @param {boolean} [options.useWasmNMS=false] - Use WASM for non-maximum suppression\r\n * @param {boolean} [options.useWasmHysteresis=false] - Use WASM for hysteresis thresholding\r\n * @param {boolean} [options.useWasmFullCanny=false] - Use the full WASM Canny implementation\r\n * @param {object} [options.debug={}] - Object to store intermediate results if provided\r\n * @returns {Promise<Uint8ClampedArray>} Binary edge image (0 or 255)\r\n */\r\nexport async function cannyEdgeDetector(imageData, options = {}) {\r\n  // Timing table setup\r\n  const timings = [];\r\n  const tStart = performance.now();\r\n\r\n  const { width, height } = imageData;\r\n  let lowThreshold = options.lowThreshold !== undefined ? options.lowThreshold : 75;\r\n  let highThreshold = options.highThreshold !== undefined ? options.highThreshold : 200;\r\n  const kernelSize = options.kernelSize || 5; // Match jscanify's 5x5 kernel\r\n  const sigma = options.sigma || 0; // Let the blur function calculate sigma\r\n  const L2gradient = options.L2gradient === undefined ? false : options.L2gradient;\r\n  const applyDilation = options.applyDilation !== undefined ? options.applyDilation : true;\r\n  const dilationKernelSize = options.dilationKernelSize || 5;\r\n  const useWasmBlur = true;\r\n  const useWasmGradients = false; \r\n  const useWasmDilation = true;\r\n  const useWasmNMS = true;\r\n  const useWasmHysteresis = options.useWasmHysteresis !== undefined ? options.useWasmHysteresis : false;\r\n  const useWasmFullCanny = false;\r\n\r\n  // Ensure high threshold is greater than low threshold\r\n  if (lowThreshold >= highThreshold) {\r\n      console.warn(`Canny Edge Detector: lowThreshold (${lowThreshold}) should be lower than highThreshold (${highThreshold}). Swapping them.`);\r\n      [lowThreshold, highThreshold] = [highThreshold, lowThreshold];\r\n  }\r\n\r\n  // Step 1: Convert to grayscale\r\n  let t0 = performance.now();\r\n  const grayscale = convertToGrayscale(imageData);\r\n  let t1 = performance.now();\r\n  timings.push({ step: 'Grayscale', ms: (t1 - t0).toFixed(2) });\r\n  if (options.debug) options.debug.grayscale = grayscale;\r\n\r\n  // Step 2: Apply Gaussian blur (JS or WASM)\r\n  let blurred;\r\n  t0 = performance.now();\r\n  if (useWasmBlur) {\r\n    try {\r\n      await wasmReady; // Ensure wasm is initialized\r\n      blurred = wasmBlur(grayscale, width, height, kernelSize, sigma);\r\n    } catch (e) {\r\n      blurred = gaussianBlurGrayscale(grayscale, width, height, kernelSize, sigma);\r\n    }\r\n  } else {\r\n    blurred = gaussianBlurGrayscale(grayscale, width, height, kernelSize, sigma);\r\n  }\r\n  t1 = performance.now();\r\n  timings.push({ step: 'Gaussian Blur', ms: (t1 - t0).toFixed(2) });\r\n  if (options.debug) {\r\n    options.debug.blurred = blurred;\r\n  }\r\n\r\n  // Step 3: Compute gradients (dx, dy)\r\n  t0 = performance.now();\r\n  let dx, dy;\r\n  if (useWasmGradients) {\r\n    try {\r\n      await wasmReady; // Ensure wasm is initialized\r\n      const gradientResult = wasmGradients(blurred, width, height);\r\n      dx = new Int16Array(gradientResult.gx);\r\n      dy = new Int16Array(gradientResult.gy);\r\n    } catch (e) {\r\n      const gradients = calculateGradients(blurred, width, height);\r\n      dx = gradients.dx;\r\n      dy = gradients.dy;\r\n    }\r\n  } else {\r\n    const gradients = calculateGradients(blurred, width, height);\r\n    dx = gradients.dx;\r\n    dy = gradients.dy;\r\n  }\r\n  t1 = performance.now();\r\n  timings.push({ step: 'Gradients', ms: (t1 - t0).toFixed(2) });\r\n\r\n  // Step 4: Apply non-maximum suppression\r\n  t0 = performance.now();\r\n  let suppressed;\r\n  if (useWasmNMS) {\r\n    try {\r\n      await wasmReady;\r\n      suppressed = await wasmMaximumSuppression(dx, dy, width, height, L2gradient);\r\n    } catch (e) {\r\n      suppressed = nonMaximumSuppression(dx, dy, width, height, L2gradient);\r\n    }\r\n  } else {\r\n    suppressed = nonMaximumSuppression(dx, dy, width, height, L2gradient);\r\n  }\r\n  t1 = performance.now();\r\n  timings.push({ step: 'Non-Max Suppression', ms: (t1 - t0).toFixed(2) });\r\n\r\n  // Step 5: Apply double thresholding and hysteresis\r\n  t0 = performance.now();\r\n  const finalLowThreshold = L2gradient ? lowThreshold * lowThreshold : lowThreshold;\r\n  const finalHighThreshold = L2gradient ? highThreshold * highThreshold : highThreshold;\r\n  \r\n  let edgeMap;\r\n  if (useWasmHysteresis) {\r\n    try {\r\n      await wasmReady;\r\n      edgeMap = wasmHysteresis(suppressed, width, height, finalLowThreshold, finalHighThreshold);\r\n    } catch (e) {\r\n      console.warn(\"WASM hysteresis failed, falling back to JS:\", e);\r\n      edgeMap = hysteresisThresholding(suppressed, width, height, finalLowThreshold, finalHighThreshold);\r\n    }\r\n  } else {\r\n    edgeMap = hysteresisThresholding(suppressed, width, height, finalLowThreshold, finalHighThreshold);\r\n  }\r\n  \r\n  t1 = performance.now();\r\n  timings.push({ step: 'Hysteresis', ms: (t1 - t0).toFixed(2) });\r\n\r\n  // Step 6: Create binary image (0 or 255)\r\n  t0 = performance.now();\r\n  const cannyEdges = new Uint8ClampedArray(width * height);\r\n  for (let i = 0; i < edgeMap.length; i++) {\r\n    cannyEdges[i] = edgeMap[i] === 2 ? 255 : 0;\r\n  }\r\n  t1 = performance.now();\r\n  timings.push({ step: 'Binary Image', ms: (t1 - t0).toFixed(2) });\r\n\r\n  // Step 7: Apply dilation if requested (matching jscanify)\r\n  t0 = performance.now();\r\n  let finalEdges = cannyEdges;\r\n  if (applyDilation) {\r\n    if (useWasmDilation) {\r\n      try {\r\n        await wasmReady; // Ensure wasm is initialized\r\n        finalEdges = wasmDilate(cannyEdges, width, height, dilationKernelSize);\r\n      } catch (e) {\r\n        finalEdges = dilateEdges(cannyEdges, width, height, dilationKernelSize);\r\n      }\r\n    } else {\r\n      finalEdges = dilateEdges(cannyEdges, width, height, dilationKernelSize);\r\n    }\r\n  }\r\n  t1 = performance.now();\r\n  timings.push({ step: 'Dilation', ms: (t1 - t0).toFixed(2) });\r\n\r\n  // Store debug info if requested\r\n  if (options.debug) {\r\n    options.debug.dx = dx; // Int16Array\r\n    options.debug.dy = dy; // Int16Array\r\n    // Calculate magnitude separately for debugging if needed\r\n     const magnitude = new Float32Array(width * height);\r\n     for (let i = 0; i < dx.length; i++) {\r\n         const gx = dx[i]; const gy = dy[i];\r\n         magnitude[i] = L2gradient ? Math.sqrt(gx * gx + gy * gy) : Math.abs(gx) + Math.abs(gy);\r\n     }\r\n     options.debug.magnitude = magnitude; // Float32Array (raw magnitude)\r\n    options.debug.suppressed = suppressed; // Float32Array (after NMS)\r\n    options.debug.edgeMap = edgeMap; // Uint8Array (0, 1, 2 values from hysteresis)\r\n    options.debug.cannyEdges = cannyEdges; // Uint8ClampedArray (0 or 255, before dilation)\r\n    options.debug.finalEdges = finalEdges; // Uint8ClampedArray (0 or 255, after dilation if applied)\r\n    options.debug.timings = timings;\r\n  }\r\n\r\n  const tEnd = performance.now();\r\n  timings.unshift({ step: 'Total', ms: (tEnd - tStart).toFixed(2) });\r\n  // Print timing table\r\n  console.table(timings);\r\n\r\n  return finalEdges; // Return the final binary edge image\r\n}\r\n\r\n/**\r\n * Full Canny edge detector implementation using WASM, for comparison or direct use\r\n * This function is intended to match the performance and output of the JS cannyEdgeDetector,\r\n * but runs entirely in WASM for potentially faster execution.\r\n * @param {ImageData} imageData - Original image data\r\n * @param {Object} options - Configuration options (same as cannyEdgeDetector)\r\n * @returns {Promise<Uint8ClampedArray>} Binary edge image (0 or 255)\r\n */\r\nexport async function cannyEdgeDetectorWasm(imageData, options = {}) {\r\n  // Directly call the WASM canny_edge_detector_full function\r\n  let result;\r\n  try {\r\n    await wasmReady; // Ensure wasm is initialized\r\n    console.log('Using WASM Full Canny');\r\n    result = wasmFullCanny(imageData.data, imageData.width, imageData.height, options.lowThreshold, options.highThreshold, options.sigma, options.kernelSize, options.L2gradient, options.applyDilation, options.dilationKernelSize);\r\n  } catch (e) {\r\n    console.error(\"WASM full Canny failed:\", e);\r\n    throw e; // Rethrow to let the caller handle the error\r\n  }\r\n  \r\n  // Convert result to Uint8ClampedArray (if not already)\r\n  const edges = new Uint8ClampedArray(result);\r\n  \r\n  return edges;\r\n}","/**\r\n * Enhanced Document Detection Module\r\n *\r\n * Provides OpenCV-level document detection with:\r\n * - CLAHE preprocessing for handling uneven lighting\r\n * - Sobel/Scharr gradient operators for better edge detection\r\n * - Adaptive thresholding\r\n * - Hough Line Transform for precise edge detection\r\n * - Document validation and confidence scoring\r\n * - Multi-candidate ranking\r\n */\r\n\r\nimport { DEFAULTS } from './constants.js';\r\nimport { convertToGrayscale } from './edgeDetection.js';\r\nimport init, {\r\n  // Core functions\r\n  blur as wasmBlur,\r\n  canny_edge_detector_full as wasmFullCanny,\r\n  dilate as wasmDilate,\r\n\r\n  // New enhanced functions\r\n  sobel_gradients_3x3 as wasmSobel3x3,\r\n  sobel_gradients_3x3_simd as wasmSobel3x3Simd,\r\n  scharr_gradients_3x3 as wasmScharr3x3,\r\n  sobel_gradients_5x5 as wasmSobel5x5,\r\n  gradient_magnitude_direction as wasmGradientMagDir,\r\n  nms_precise as wasmNmsPrecise,\r\n\r\n  // Adaptive thresholding\r\n  adaptive_threshold_mean as wasmAdaptiveThresholdMean,\r\n  adaptive_threshold_gaussian as wasmAdaptiveThresholdGaussian,\r\n  adaptive_threshold_sauvola as wasmAdaptiveThresholdSauvola,\r\n  compute_adaptive_canny_thresholds as wasmComputeCannyThresholds,\r\n  otsu_threshold as wasmOtsuThreshold,\r\n\r\n  // CLAHE and preprocessing\r\n  clahe as wasmClahe,\r\n  preprocess_document as wasmPreprocessDocument,\r\n  contrast_stretch as wasmContrastStretch,\r\n  illumination_normalize as wasmIlluminationNormalize,\r\n\r\n  // Hough transform\r\n  hough_lines as wasmHoughLines,\r\n  hough_lines_p as wasmHoughLinesP,\r\n  find_line_intersections as wasmFindIntersections,\r\n  find_document_quadrilateral as wasmFindQuadrilateral,\r\n\r\n  // Document validation\r\n  validate_quadrilateral as wasmValidateQuadrilateral,\r\n  calculate_edge_strength as wasmCalculateEdgeStrength,\r\n  calculate_size_score as wasmCalculateSizeScore,\r\n  calculate_detection_confidence as wasmCalculateConfidence,\r\n  refine_corners_subpixel as wasmRefineCorners,\r\n\r\n  // Morphological operations\r\n  morphological_close as wasmMorphClose,\r\n  morphological_open as wasmMorphOpen,\r\n  close_edge_gaps as wasmCloseEdgeGaps,\r\n  remove_small_components as wasmRemoveSmallComponents,\r\n  thin_edges as wasmThinEdges,\r\n} from '../wasm_blur/pkg/wasm_blur.js';\r\n\r\n// Initialize WASM\r\nconst wasmReady = init();\r\n\r\n/**\r\n * Detection pipeline configuration\r\n */\r\nexport const DETECTION_PRESETS = {\r\n  // Fast detection with reasonable accuracy\r\n  fast: {\r\n    preprocessing: {\r\n      enableClahe: false,\r\n      enableIlluminationNorm: false,\r\n    },\r\n    edge: {\r\n      gradientOperator: 'sobel3x3',\r\n      adaptiveThreshold: false,\r\n      lowThreshold: 50,\r\n      highThreshold: 150,\r\n    },\r\n    postprocessing: {\r\n      closeGaps: false,\r\n      removeNoise: false,\r\n    },\r\n    detection: {\r\n      useHoughLines: false,\r\n      minConfidence: 0.3,\r\n    },\r\n  },\r\n\r\n  // Balanced detection (recommended for most cases)\r\n  balanced: {\r\n    preprocessing: {\r\n      enableClahe: true,\r\n      claheClip: 2.0,\r\n      claheGrid: 8,\r\n      enableIlluminationNorm: false,\r\n    },\r\n    edge: {\r\n      gradientOperator: 'sobel3x3',\r\n      adaptiveThreshold: true,\r\n      adaptiveMethod: 'percentile', // 'fixed', 'otsu', 'percentile'\r\n    },\r\n    postprocessing: {\r\n      closeGaps: true,\r\n      gapSize: 5,\r\n      removeNoise: true,\r\n      minComponentArea: 100,\r\n    },\r\n    detection: {\r\n      useHoughLines: true,\r\n      houghThreshold: 50,\r\n      minLineLength: 30,\r\n      maxLineGap: 10,\r\n      minConfidence: 0.4,\r\n    },\r\n  },\r\n\r\n  // High accuracy detection (slower but more reliable)\r\n  accurate: {\r\n    preprocessing: {\r\n      enableClahe: true,\r\n      claheClip: 2.5,\r\n      claheGrid: 8,\r\n      enableIlluminationNorm: true,\r\n    },\r\n    edge: {\r\n      gradientOperator: 'scharr3x3', // Better rotational accuracy\r\n      adaptiveThreshold: true,\r\n      adaptiveMethod: 'percentile',\r\n    },\r\n    postprocessing: {\r\n      closeGaps: true,\r\n      gapSize: 7,\r\n      removeNoise: true,\r\n      minComponentArea: 150,\r\n      thinEdges: true,\r\n    },\r\n    detection: {\r\n      useHoughLines: true,\r\n      houghThreshold: 30,\r\n      minLineLength: 20,\r\n      maxLineGap: 15,\r\n      minConfidence: 0.5,\r\n      refineCorners: true,\r\n    },\r\n  },\r\n\r\n  // ID document optimized (passports, driver's licenses, ID cards)\r\n  idDocument: {\r\n    preprocessing: {\r\n      enableClahe: true,\r\n      claheClip: 3.0,\r\n      claheGrid: 8,\r\n      enableIlluminationNorm: true,\r\n    },\r\n    edge: {\r\n      gradientOperator: 'scharr3x3',\r\n      adaptiveThreshold: true,\r\n      adaptiveMethod: 'percentile',\r\n    },\r\n    postprocessing: {\r\n      closeGaps: true,\r\n      gapSize: 5,\r\n      removeNoise: true,\r\n      minComponentArea: 100,\r\n    },\r\n    detection: {\r\n      useHoughLines: true,\r\n      houghThreshold: 40,\r\n      minLineLength: 25,\r\n      maxLineGap: 10,\r\n      minConfidence: 0.5,\r\n      refineCorners: true,\r\n      // ID documents have specific aspect ratios\r\n      validateAspectRatio: true,\r\n      expectedAspectRatios: [1.586, 1.42], // CR-80, Passport\r\n      aspectTolerance: 0.15,\r\n    },\r\n  },\r\n};\r\n\r\n/**\r\n * Enhanced preprocessing pipeline\r\n */\r\nasync function preprocessImage(grayscale, width, height, options) {\r\n  await wasmReady;\r\n\r\n  let processed = grayscale;\r\n  const timings = [];\r\n\r\n  // Step 1: Illumination normalization\r\n  if (options.enableIlluminationNorm) {\r\n    const t0 = performance.now();\r\n    const sigma = Math.min(width, height) / 10;\r\n    processed = wasmIlluminationNormalize(processed, width, height, sigma);\r\n    timings.push({ step: 'Illumination Norm', ms: (performance.now() - t0).toFixed(2) });\r\n  }\r\n\r\n  // Step 2: CLAHE\r\n  if (options.enableClahe) {\r\n    const t0 = performance.now();\r\n    processed = wasmClahe(\r\n      processed,\r\n      width,\r\n      height,\r\n      options.claheGrid || 8,\r\n      options.claheGrid || 8,\r\n      options.claheClip || 2.0\r\n    );\r\n    timings.push({ step: 'CLAHE', ms: (performance.now() - t0).toFixed(2) });\r\n  }\r\n\r\n  // Step 3: Contrast stretch\r\n  if (options.enableContrastStretch) {\r\n    const t0 = performance.now();\r\n    processed = wasmContrastStretch(processed, width, height);\r\n    timings.push({ step: 'Contrast Stretch', ms: (performance.now() - t0).toFixed(2) });\r\n  }\r\n\r\n  return { processed, timings };\r\n}\r\n\r\n/**\r\n * Enhanced gradient calculation\r\n */\r\nasync function calculateGradients(blurred, width, height, options) {\r\n  await wasmReady;\r\n\r\n  const operator = options.gradientOperator || 'sobel3x3';\r\n  let gradients;\r\n\r\n  const t0 = performance.now();\r\n\r\n  switch (operator) {\r\n    case 'scharr3x3':\r\n      gradients = wasmScharr3x3(blurred, width, height);\r\n      break;\r\n    case 'sobel5x5':\r\n      gradients = wasmSobel5x5(blurred, width, height);\r\n      break;\r\n    case 'sobel3x3_simd':\r\n      gradients = wasmSobel3x3Simd(blurred, width, height);\r\n      break;\r\n    case 'sobel3x3':\r\n    default:\r\n      gradients = wasmSobel3x3(blurred, width, height);\r\n      break;\r\n  }\r\n\r\n  const elapsed = performance.now() - t0;\r\n\r\n  return { gradients, elapsed };\r\n}\r\n\r\n/**\r\n * Compute adaptive Canny thresholds\r\n */\r\nasync function computeAdaptiveThresholds(magnitude, width, height, options) {\r\n  await wasmReady;\r\n\r\n  const method = options.adaptiveMethod || 'percentile';\r\n\r\n  switch (method) {\r\n    case 'otsu': {\r\n      // Use Otsu's method on magnitude histogram\r\n      const magnitudeU8 = new Uint8Array(magnitude.length);\r\n      const maxMag = Math.max(...magnitude);\r\n      for (let i = 0; i < magnitude.length; i++) {\r\n        magnitudeU8[i] = Math.min(255, Math.floor(magnitude[i] / maxMag * 255));\r\n      }\r\n      const otsuThresh = wasmOtsuThreshold(magnitudeU8, width, height);\r\n      return {\r\n        low: otsuThresh * 0.4 * maxMag / 255,\r\n        high: otsuThresh * maxMag / 255,\r\n      };\r\n    }\r\n\r\n    case 'percentile':\r\n    default: {\r\n      const thresholds = wasmComputeCannyThresholds(magnitude, width, height, 0.4, 0.7);\r\n      return {\r\n        low: thresholds[0],\r\n        high: thresholds[1],\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Enhanced edge detection with all improvements\r\n */\r\nexport async function enhancedEdgeDetection(imageData, options = {}) {\r\n  await wasmReady;\r\n\r\n  const { width, height } = imageData;\r\n  const config = options.preset ? DETECTION_PRESETS[options.preset] : options;\r\n  const preprocessing = config.preprocessing || {};\r\n  const edgeConfig = config.edge || {};\r\n  const postConfig = config.postprocessing || {};\r\n\r\n  const timings = [];\r\n  const debug = options.debug ? {} : null;\r\n\r\n  // Step 1: Convert to grayscale\r\n  let t0 = performance.now();\r\n  const grayscale = convertToGrayscale(imageData);\r\n  timings.push({ step: 'Grayscale', ms: (performance.now() - t0).toFixed(2) });\r\n\r\n  if (debug) debug.grayscale = grayscale;\r\n\r\n  // Step 2: Preprocessing\r\n  const { processed, timings: prepTimings } = await preprocessImage(\r\n    grayscale, width, height, preprocessing\r\n  );\r\n  timings.push(...prepTimings);\r\n\r\n  if (debug) debug.preprocessed = processed;\r\n\r\n  // Step 3: Gaussian blur\r\n  t0 = performance.now();\r\n  const kernelSize = edgeConfig.kernelSize || 5;\r\n  const sigma = edgeConfig.sigma || 0;\r\n  const blurred = wasmBlur(processed, width, height, kernelSize, sigma);\r\n  timings.push({ step: 'Gaussian Blur', ms: (performance.now() - t0).toFixed(2) });\r\n\r\n  if (debug) debug.blurred = blurred;\r\n\r\n  // Step 4: Calculate gradients using enhanced operators\r\n  const { gradients, elapsed: gradientTime } = await calculateGradients(\r\n    blurred, width, height, edgeConfig\r\n  );\r\n  timings.push({ step: 'Gradients', ms: gradientTime.toFixed(2) });\r\n\r\n  // Step 5: Compute magnitude and direction\r\n  t0 = performance.now();\r\n  const magDir = wasmGradientMagDir(gradients, width, height, true);\r\n  const magnitude = new Float32Array(width * height);\r\n  const direction = new Float32Array(width * height);\r\n  for (let i = 0; i < width * height; i++) {\r\n    magnitude[i] = magDir[2 * i];\r\n    direction[i] = magDir[2 * i + 1];\r\n  }\r\n  timings.push({ step: 'Magnitude/Direction', ms: (performance.now() - t0).toFixed(2) });\r\n\r\n  if (debug) {\r\n    debug.magnitude = magnitude;\r\n    debug.direction = direction;\r\n    debug.gradients = gradients;\r\n  }\r\n\r\n  // Step 6: Non-maximum suppression with precise direction\r\n  t0 = performance.now();\r\n  const suppressed = wasmNmsPrecise(magnitude, direction, width, height);\r\n  timings.push({ step: 'NMS (Precise)', ms: (performance.now() - t0).toFixed(2) });\r\n\r\n  if (debug) debug.suppressed = suppressed;\r\n\r\n  // Step 7: Compute adaptive thresholds or use fixed\r\n  let lowThreshold = edgeConfig.lowThreshold || 50;\r\n  let highThreshold = edgeConfig.highThreshold || 150;\r\n\r\n  if (edgeConfig.adaptiveThreshold) {\r\n    t0 = performance.now();\r\n    const adaptive = await computeAdaptiveThresholds(suppressed, width, height, edgeConfig);\r\n    lowThreshold = adaptive.low;\r\n    highThreshold = adaptive.high;\r\n    timings.push({ step: 'Adaptive Threshold', ms: (performance.now() - t0).toFixed(2) });\r\n\r\n    if (debug) {\r\n      debug.adaptiveThresholds = { low: lowThreshold, high: highThreshold };\r\n    }\r\n  }\r\n\r\n  // Step 8: Hysteresis thresholding (use full Canny from this point)\r\n  t0 = performance.now();\r\n\r\n  // Create binary edge map from suppressed\r\n  const edgeMap = new Uint8Array(width * height);\r\n  for (let i = 0; i < suppressed.length; i++) {\r\n    if (suppressed[i] >= highThreshold) {\r\n      edgeMap[i] = 255;\r\n    } else if (suppressed[i] >= lowThreshold) {\r\n      edgeMap[i] = 128; // Weak edge\r\n    }\r\n  }\r\n\r\n  // Connect weak edges to strong edges (simple hysteresis)\r\n  const finalEdges = performHysteresis(edgeMap, width, height);\r\n  timings.push({ step: 'Hysteresis', ms: (performance.now() - t0).toFixed(2) });\r\n\r\n  if (debug) debug.beforePost = new Uint8Array(finalEdges);\r\n\r\n  // Step 9: Post-processing\r\n  let postProcessed = finalEdges;\r\n\r\n  if (postConfig.closeGaps) {\r\n    t0 = performance.now();\r\n    postProcessed = wasmCloseEdgeGaps(postProcessed, width, height, postConfig.gapSize || 5);\r\n    timings.push({ step: 'Close Gaps', ms: (performance.now() - t0).toFixed(2) });\r\n  }\r\n\r\n  if (postConfig.removeNoise) {\r\n    t0 = performance.now();\r\n    postProcessed = wasmRemoveSmallComponents(\r\n      postProcessed, width, height, postConfig.minComponentArea || 100\r\n    );\r\n    timings.push({ step: 'Remove Noise', ms: (performance.now() - t0).toFixed(2) });\r\n  }\r\n\r\n  if (postConfig.thinEdges) {\r\n    t0 = performance.now();\r\n    postProcessed = wasmThinEdges(postProcessed, width, height);\r\n    timings.push({ step: 'Thin Edges', ms: (performance.now() - t0).toFixed(2) });\r\n  }\r\n\r\n  if (debug) {\r\n    debug.finalEdges = postProcessed;\r\n    debug.timings = timings;\r\n  }\r\n\r\n  console.table(timings);\r\n\r\n  return {\r\n    edges: new Uint8ClampedArray(postProcessed),\r\n    gradients,\r\n    magnitude,\r\n    direction,\r\n    debug,\r\n  };\r\n}\r\n\r\n/**\r\n * Simple hysteresis implementation\r\n */\r\nfunction performHysteresis(edgeMap, width, height) {\r\n  const output = new Uint8Array(width * height);\r\n  const visited = new Uint8Array(width * height);\r\n  const stack = [];\r\n\r\n  // Find strong edges\r\n  for (let i = 0; i < edgeMap.length; i++) {\r\n    if (edgeMap[i] === 255) {\r\n      output[i] = 255;\r\n      stack.push(i);\r\n    }\r\n  }\r\n\r\n  // Propagate to connected weak edges\r\n  const offsets = [-width - 1, -width, -width + 1, -1, 1, width - 1, width, width + 1];\r\n\r\n  while (stack.length > 0) {\r\n    const idx = stack.pop();\r\n    const x = idx % width;\r\n    const y = Math.floor(idx / width);\r\n\r\n    for (const offset of offsets) {\r\n      const nidx = idx + offset;\r\n      const nx = nidx % width;\r\n\r\n      // Check bounds and avoid wrap-around\r\n      if (nidx >= 0 && nidx < edgeMap.length &&\r\n          Math.abs(nx - x) <= 1 && !visited[nidx]) {\r\n        visited[nidx] = 1;\r\n\r\n        if (edgeMap[nidx] === 128) { // Weak edge\r\n          output[nidx] = 255;\r\n          stack.push(nidx);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return output;\r\n}\r\n\r\n/**\r\n * Detect document using Hough Line Transform\r\n */\r\nexport async function detectDocumentHough(edges, width, height, options = {}) {\r\n  await wasmReady;\r\n\r\n  const config = options.detection || options;\r\n  const timings = [];\r\n\r\n  // Step 1: Hough Line Transform\r\n  let t0 = performance.now();\r\n  const lines = wasmHoughLines(\r\n    edges,\r\n    width,\r\n    height,\r\n    1.0, // rho resolution\r\n    1.0, // theta resolution (degrees)\r\n    config.houghThreshold || 50,\r\n    100  // max lines\r\n  );\r\n  timings.push({ step: 'Hough Lines', ms: (performance.now() - t0).toFixed(2) });\r\n\r\n  const numLines = lines.length / 3;\r\n  console.log(`Detected ${numLines} lines`);\r\n\r\n  if (numLines < 4) {\r\n    return {\r\n      success: false,\r\n      message: 'Not enough lines detected',\r\n      timings,\r\n    };\r\n  }\r\n\r\n  // Step 2: Find document quadrilateral\r\n  t0 = performance.now();\r\n  const quad = wasmFindQuadrilateral(\r\n    lines,\r\n    width,\r\n    height,\r\n    config.minAreaRatio || 0.05,\r\n    config.maxAreaRatio || 0.95\r\n  );\r\n  timings.push({ step: 'Find Quadrilateral', ms: (performance.now() - t0).toFixed(2) });\r\n\r\n  if (quad.length === 0) {\r\n    return {\r\n      success: false,\r\n      message: 'No valid quadrilateral found',\r\n      lines: parseLines(lines),\r\n      timings,\r\n    };\r\n  }\r\n\r\n  // Extract corners and confidence\r\n  const corners = {\r\n    topLeft: { x: quad[0], y: quad[1] },\r\n    topRight: { x: quad[2], y: quad[3] },\r\n    bottomRight: { x: quad[4], y: quad[5] },\r\n    bottomLeft: { x: quad[6], y: quad[7] },\r\n  };\r\n  const lineConfidence = quad[8];\r\n\r\n  // Step 3: Validate quadrilateral\r\n  t0 = performance.now();\r\n  const validation = wasmValidateQuadrilateral(new Float32Array([\r\n    quad[0], quad[1], quad[2], quad[3], quad[4], quad[5], quad[6], quad[7]\r\n  ]));\r\n  timings.push({ step: 'Validate Quad', ms: (performance.now() - t0).toFixed(2) });\r\n\r\n  const validationResult = {\r\n    shapeScore: validation[0],\r\n    convexityScore: validation[1],\r\n    angleScore: validation[2],\r\n    parallelismScore: validation[3],\r\n    aspectRatio: validation[4],\r\n    aspectScore: validation[5],\r\n    documentType: ['unknown', 'id_card', 'passport', 'paper'][validation[6]] || 'unknown',\r\n  };\r\n\r\n  // Step 4: Calculate size score\r\n  const sizeScore = wasmCalculateSizeScore(\r\n    new Float32Array([quad[0], quad[1], quad[2], quad[3], quad[4], quad[5], quad[6], quad[7]]),\r\n    width,\r\n    height,\r\n    0.05, // min coverage\r\n    0.95, // max coverage\r\n    0.3   // ideal coverage\r\n  );\r\n\r\n  // Step 5: Calculate overall confidence\r\n  const confidence = wasmCalculateConfidence(\r\n    lineConfidence / 100, // Normalize line confidence\r\n    validationResult.shapeScore,\r\n    validationResult.aspectScore,\r\n    sizeScore\r\n  );\r\n\r\n  console.table(timings);\r\n\r\n  return {\r\n    success: confidence >= (config.minConfidence || 0.4),\r\n    corners,\r\n    confidence,\r\n    validation: validationResult,\r\n    sizeScore,\r\n    lines: parseLines(lines),\r\n    timings,\r\n  };\r\n}\r\n\r\n/**\r\n * Parse flat line array into structured format\r\n */\r\nfunction parseLines(lines) {\r\n  const result = [];\r\n  for (let i = 0; i < lines.length; i += 3) {\r\n    result.push({\r\n      rho: lines[i],\r\n      theta: lines[i + 1],\r\n      thetaDegrees: lines[i + 1] * 180 / Math.PI,\r\n      votes: lines[i + 2],\r\n    });\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Complete enhanced document detection pipeline\r\n */\r\nexport async function enhancedDocumentDetection(imageData, options = {}) {\r\n  await wasmReady;\r\n\r\n  const preset = options.preset || 'balanced';\r\n  const config = DETECTION_PRESETS[preset] || DETECTION_PRESETS.balanced;\r\n\r\n  // Merge options with preset\r\n  const mergedConfig = {\r\n    ...config,\r\n    ...options,\r\n    preprocessing: { ...config.preprocessing, ...options.preprocessing },\r\n    edge: { ...config.edge, ...options.edge },\r\n    postprocessing: { ...config.postprocessing, ...options.postprocessing },\r\n    detection: { ...config.detection, ...options.detection },\r\n  };\r\n\r\n  const { width, height } = imageData;\r\n  const debug = options.debug ? {} : null;\r\n\r\n  // Step 1: Enhanced edge detection\r\n  const edgeResult = await enhancedEdgeDetection(imageData, {\r\n    ...mergedConfig,\r\n    debug: debug ? {} : null,\r\n  });\r\n\r\n  if (debug) {\r\n    debug.edgeDetection = edgeResult.debug;\r\n  }\r\n\r\n  // Step 2: Document detection using Hough or contour method\r\n  let detection;\r\n\r\n  if (mergedConfig.detection.useHoughLines) {\r\n    detection = await detectDocumentHough(\r\n      edgeResult.edges,\r\n      width,\r\n      height,\r\n      mergedConfig\r\n    );\r\n\r\n    // If Hough fails, fall back to contour detection\r\n    if (!detection.success) {\r\n      console.log('Hough detection failed, trying contour detection...');\r\n      // Import and use the existing contour detection\r\n      const { detectDocumentContour } = await import('./contourDetection.js');\r\n      const { findCornerPoints } = await import('./cornerDetection.js');\r\n\r\n      const contours = detectDocumentContour(edgeResult.edges, {\r\n        minArea: 1000,\r\n        width,\r\n        height,\r\n      });\r\n\r\n      if (contours && contours.length > 0) {\r\n        const corners = findCornerPoints(contours[0]);\r\n\r\n        // Validate the contour-detected corners\r\n        const cornersArray = new Float32Array([\r\n          corners.topLeft.x, corners.topLeft.y,\r\n          corners.topRight.x, corners.topRight.y,\r\n          corners.bottomRight.x, corners.bottomRight.y,\r\n          corners.bottomLeft.x, corners.bottomLeft.y,\r\n        ]);\r\n\r\n        const validation = wasmValidateQuadrilateral(cornersArray);\r\n        const sizeScore = wasmCalculateSizeScore(cornersArray, width, height, 0.05, 0.95, 0.3);\r\n\r\n        // Calculate edge strength using gradients\r\n        const edgeScore = wasmCalculateEdgeStrength(\r\n          edgeResult.gradients,\r\n          width,\r\n          height,\r\n          cornersArray,\r\n          20 // sample points\r\n        );\r\n\r\n        const confidence = wasmCalculateConfidence(edgeScore, validation[0], validation[5], sizeScore);\r\n\r\n        detection = {\r\n          success: confidence >= (mergedConfig.detection.minConfidence || 0.4),\r\n          corners,\r\n          confidence,\r\n          validation: {\r\n            shapeScore: validation[0],\r\n            convexityScore: validation[1],\r\n            angleScore: validation[2],\r\n            parallelismScore: validation[3],\r\n            aspectRatio: validation[4],\r\n            aspectScore: validation[5],\r\n            documentType: ['unknown', 'id_card', 'passport', 'paper'][validation[6]] || 'unknown',\r\n          },\r\n          sizeScore,\r\n          edgeScore,\r\n          method: 'contour',\r\n        };\r\n      }\r\n    } else {\r\n      detection.method = 'hough';\r\n    }\r\n  } else {\r\n    // Use contour detection directly\r\n    const { detectDocumentContour } = await import('./contourDetection.js');\r\n    const { findCornerPoints } = await import('./cornerDetection.js');\r\n\r\n    const contours = detectDocumentContour(edgeResult.edges, {\r\n      minArea: 1000,\r\n      width,\r\n      height,\r\n    });\r\n\r\n    if (contours && contours.length > 0) {\r\n      const corners = findCornerPoints(contours[0]);\r\n\r\n      const cornersArray = new Float32Array([\r\n        corners.topLeft.x, corners.topLeft.y,\r\n        corners.topRight.x, corners.topRight.y,\r\n        corners.bottomRight.x, corners.bottomRight.y,\r\n        corners.bottomLeft.x, corners.bottomLeft.y,\r\n      ]);\r\n\r\n      const validation = wasmValidateQuadrilateral(cornersArray);\r\n      const sizeScore = wasmCalculateSizeScore(cornersArray, width, height, 0.05, 0.95, 0.3);\r\n      const edgeScore = wasmCalculateEdgeStrength(edgeResult.gradients, width, height, cornersArray, 20);\r\n      const confidence = wasmCalculateConfidence(edgeScore, validation[0], validation[5], sizeScore);\r\n\r\n      detection = {\r\n        success: confidence >= (mergedConfig.detection.minConfidence || 0.4),\r\n        corners,\r\n        confidence,\r\n        validation: {\r\n          shapeScore: validation[0],\r\n          convexityScore: validation[1],\r\n          angleScore: validation[2],\r\n          parallelismScore: validation[3],\r\n          aspectRatio: validation[4],\r\n          aspectScore: validation[5],\r\n          documentType: ['unknown', 'id_card', 'passport', 'paper'][validation[6]] || 'unknown',\r\n        },\r\n        sizeScore,\r\n        edgeScore,\r\n        method: 'contour',\r\n      };\r\n    } else {\r\n      detection = {\r\n        success: false,\r\n        message: 'No document contours found',\r\n      };\r\n    }\r\n  }\r\n\r\n  // Step 3: Refine corners if enabled and detection succeeded\r\n  if (detection.success && mergedConfig.detection.refineCorners && detection.corners) {\r\n    const cornersArray = new Float32Array([\r\n      detection.corners.topLeft.x, detection.corners.topLeft.y,\r\n      detection.corners.topRight.x, detection.corners.topRight.y,\r\n      detection.corners.bottomRight.x, detection.corners.bottomRight.y,\r\n      detection.corners.bottomLeft.x, detection.corners.bottomLeft.y,\r\n    ]);\r\n\r\n    const refined = wasmRefineCorners(edgeResult.gradients, width, height, cornersArray, 5);\r\n\r\n    detection.corners = {\r\n      topLeft: { x: refined[0], y: refined[1] },\r\n      topRight: { x: refined[2], y: refined[3] },\r\n      bottomRight: { x: refined[4], y: refined[5] },\r\n      bottomLeft: { x: refined[6], y: refined[7] },\r\n    };\r\n    detection.cornersRefined = true;\r\n  }\r\n\r\n  if (debug) {\r\n    debug.detection = detection;\r\n    debug.edges = edgeResult.edges;\r\n  }\r\n\r\n  return {\r\n    ...detection,\r\n    edges: edgeResult.edges,\r\n    debug,\r\n  };\r\n}\r\n\r\n/**\r\n * Quick document detection for live camera preview\r\n * Uses fastest settings for real-time performance\r\n */\r\nexport async function quickDocumentDetection(imageData, options = {}) {\r\n  return enhancedDocumentDetection(imageData, {\r\n    preset: 'fast',\r\n    ...options,\r\n  });\r\n}\r\n\r\n/**\r\n * ID document detection optimized for passports and ID cards\r\n */\r\nexport async function detectIDDocument(imageData, options = {}) {\r\n  return enhancedDocumentDetection(imageData, {\r\n    preset: 'idDocument',\r\n    ...options,\r\n  });\r\n}\r\n\r\n// Export presets for customization\r\nexport { DETECTION_PRESETS as presets };\r\n","/**\r\n * Scanic - Modern Document Scanner for the Web\r\n *\r\n * A blazing-fast, lightweight document scanner library written in JavaScript and Rust (WASM).\r\n * Enables developers to detect, scan, and process documents from images directly in the browser.\r\n *\r\n * @module scanic\r\n * @version 0.1.8\r\n * @license MIT\r\n * @author marquaye\r\n *\r\n * @example\r\n * // Basic document detection\r\n * import { scanDocument } from 'scanic';\r\n * const result = await scanDocument(imageElement);\r\n * if (result.success) {\r\n *   console.log('Document corners:', result.corners);\r\n * }\r\n *\r\n * @example\r\n * // Extract document with perspective correction\r\n * const extracted = await scanDocument(imageElement, { mode: 'extract' });\r\n * if (extracted.success) {\r\n *   document.body.appendChild(extracted.output);\r\n * }\r\n *\r\n * @example\r\n * // Detect ID documents (passports, licenses)\r\n * import { detectIDDocument } from 'scanic';\r\n * const idResult = await detectIDDocument(imageElement);\r\n * console.log('Document type:', idResult.validation.documentType);\r\n */\r\n\r\nimport { detectDocumentContour } from './contourDetection.js';\r\nimport { findCornerPoints } from './cornerDetection.js';\r\nimport { cannyEdgeDetector } from './edgeDetection.js';\r\n\r\n\r\n// Helper function to calculate smart adaptive downscale factor\r\nfunction calculateAdaptiveDownscale(imageData, maxDimension = 800) {\r\n  const { width, height } = imageData;\r\n  const maxCurrentDimension = Math.max(width, height);\r\n  \r\n  // If image is already smaller than target, no scaling needed\r\n  if (maxCurrentDimension <= maxDimension) {\r\n    return {\r\n      scaledImageData: imageData,\r\n      scaleFactor: 1,\r\n      originalDimensions: { width, height },\r\n      scaledDimensions: { width, height }\r\n    };\r\n  }\r\n  \r\n  // Calculate scale factor to fit within maxDimension\r\n  const scaleFactor = maxDimension / maxCurrentDimension;\r\n  const scaledWidth = Math.round(width * scaleFactor);\r\n  const scaledHeight = Math.round(height * scaleFactor);\r\n  \r\n  // Create scaled image data\r\n  const tempCanvas = document.createElement('canvas');\r\n  tempCanvas.width = width;\r\n  tempCanvas.height = height;\r\n  const tempCtx = tempCanvas.getContext('2d');\r\n  tempCtx.putImageData(imageData, 0, 0);\r\n\r\n  const scaledCanvas = document.createElement('canvas');\r\n  scaledCanvas.width = scaledWidth;\r\n  scaledCanvas.height = scaledHeight;\r\n  const scaledCtx = scaledCanvas.getContext('2d');\r\n  \r\n  // Use high-quality scaling\r\n  scaledCtx.imageSmoothingEnabled = true;\r\n  scaledCtx.imageSmoothingQuality = 'high';\r\n  scaledCtx.drawImage(tempCanvas, 0, 0, width, height, 0, 0, scaledWidth, scaledHeight);\r\n  \r\n  const scaledImageData = scaledCtx.getImageData(0, 0, scaledWidth, scaledHeight);\r\n  \r\n  return {\r\n    scaledImageData,\r\n    scaleFactor: 1 / scaleFactor, // Return inverse for compatibility with existing code\r\n    originalDimensions: { width, height },\r\n    scaledDimensions: { width: scaledWidth, height: scaledHeight }\r\n  };\r\n}\r\n\r\n// Internal function to detect document in image\r\nasync function detectDocumentInternal(imageData, options = {}) {\r\n  const debugInfo = options.debug ? {} : null;\r\n  \r\n  // Smart adaptive downscaling - ensure largest dimension doesn't exceed maxProcessingDimension\r\n  const maxProcessingDimension = options.maxProcessingDimension || 800;\r\n  const { scaledImageData, scaleFactor, originalDimensions, scaledDimensions } = \r\n    calculateAdaptiveDownscale(imageData, maxProcessingDimension);\r\n  \r\n  if (debugInfo) {\r\n    debugInfo.preprocessing = {\r\n      originalDimensions,\r\n      scaledDimensions,\r\n      scaleFactor,\r\n      maxProcessingDimension\r\n    };\r\n  }\r\n  \r\n  const { width, height } = scaledImageData; // Use scaled dimensions\r\n  \r\n  // Run edge detection on the adaptively scaled image\r\n  const edges = await cannyEdgeDetector(scaledImageData, {\r\n    lowThreshold: options.lowThreshold || 75,   // Match OpenCV values\r\n    highThreshold: options.highThreshold || 200, // Match OpenCV values\r\n    dilationKernelSize: options.dilationKernelSize || 3, // Match OpenCV value \r\n    dilationIterations: options.dilationIterations || 1,\r\n    debug: debugInfo,\r\n    skipNMS: false, // options.skipNMS // Optional flag to skip non-max suppression\r\n    useWasmBlur: true, // option to use wasm blur\r\n  });\r\n  \r\n  // Detect contours from edges\r\n  const contours = detectDocumentContour(edges, {\r\n    minArea: (options.minArea || 1000) / (scaleFactor * scaleFactor), // Adjust minArea for scaled image\r\n    debug: debugInfo,\r\n    width: width,     \r\n    height: height    \r\n  });\r\n\r\n  if (!contours || contours.length === 0) {\r\n    console.log('No document detected');\r\n    return {\r\n      success: false,\r\n      message: 'No document detected',\r\n      debug: debugInfo\r\n    };\r\n  }\r\n  \r\n  // Get the largest contour which is likely the document\r\n  const documentContour = contours[0]; \r\n  \r\n  // Find corner points on the scaled image\r\n  const cornerPoints = findCornerPoints(documentContour, { \r\n      epsilon: options.epsilon // Pass epsilon for approximation\r\n  });\r\n  \r\n  // Scale corner points back to original image size\r\n  let finalCorners = cornerPoints;\r\n  if (scaleFactor !== 1) {\r\n    finalCorners = {\r\n      topLeft: { x: cornerPoints.topLeft.x * scaleFactor, y: cornerPoints.topLeft.y * scaleFactor },\r\n      topRight: { x: cornerPoints.topRight.x * scaleFactor, y: cornerPoints.topRight.y * scaleFactor },\r\n      bottomRight: { x: cornerPoints.bottomRight.x * scaleFactor, y: cornerPoints.bottomRight.y * scaleFactor },\r\n      bottomLeft: { x: cornerPoints.bottomLeft.x * scaleFactor, y: cornerPoints.bottomLeft.y * scaleFactor },\r\n    };\r\n  }\r\n  \r\n  // Return the result, scaling the contour points back up as well\r\n  return {\r\n    success: true,\r\n    contour: documentContour,\r\n    corners: finalCorners,\r\n    debug: debugInfo\r\n  };\r\n}\r\n\r\n// --- Perspective transform helpers (internal use only) ---\r\nfunction getPerspectiveTransform(srcPoints, dstPoints) {\r\n  // Helper to build the system of equations\r\n  function buildMatrix(points) {\r\n    const matrix = [];\r\n    for (let i = 0; i < 4; i++) {\r\n      const [x, y] = points[i];\r\n      matrix.push([x, y, 1, 0, 0, 0, -x * dstPoints[i][0], -y * dstPoints[i][0]]);\r\n      matrix.push([0, 0, 0, x, y, 1, -x * dstPoints[i][1], -y * dstPoints[i][1]]);\r\n    }\r\n    return matrix;\r\n  }\r\n\r\n  const A = buildMatrix(srcPoints);\r\n  const b = [\r\n    dstPoints[0][0], dstPoints[0][1],\r\n    dstPoints[1][0], dstPoints[1][1],\r\n    dstPoints[2][0], dstPoints[2][1],\r\n    dstPoints[3][0], dstPoints[3][1]\r\n  ];\r\n\r\n  // Solve Ah = b for h (h is 8x1, last element is 1)\r\n  // Use Gaussian elimination or Cramer's rule for 8x8\r\n  // For simplicity, use numeric.js if available, else implement basic solver\r\n  function solve(A, b) {\r\n    // Gaussian elimination for 8x8\r\n    const m = A.length;\r\n    const n = A[0].length;\r\n    const M = A.map(row => row.slice());\r\n    const B = b.slice();\r\n\r\n    for (let i = 0; i < n; i++) {\r\n      // Find max row\r\n      let maxRow = i;\r\n      for (let k = i + 1; k < m; k++) {\r\n        if (Math.abs(M[k][i]) > Math.abs(M[maxRow][i])) maxRow = k;\r\n      }\r\n      // Swap rows\r\n      [M[i], M[maxRow]] = [M[maxRow], M[i]];\r\n      [B[i], B[maxRow]] = [B[maxRow], B[i]];\r\n\r\n      // Eliminate\r\n      for (let k = i + 1; k < m; k++) {\r\n        const c = M[k][i] / M[i][i];\r\n        for (let j = i; j < n; j++) {\r\n          M[k][j] -= c * M[i][j];\r\n        }\r\n        B[k] -= c * B[i];\r\n      }\r\n    }\r\n\r\n    // Back substitution\r\n    const x = new Array(n);\r\n    for (let i = n - 1; i >= 0; i--) {\r\n      let sum = B[i];\r\n      for (let j = i + 1; j < n; j++) {\r\n        sum -= M[i][j] * x[j];\r\n      }\r\n      x[i] = sum / M[i][i];\r\n    }\r\n    return x;\r\n  }\r\n\r\n  const h = solve(A, b);\r\n  // h is [h0,h1,h2,h3,h4,h5,h6,h7], h8 = 1\r\n  const matrix = [\r\n    [h[0], h[1], h[2]],\r\n    [h[3], h[4], h[5]],\r\n    [h[6], h[7], 1]\r\n  ];\r\n  return matrix;\r\n}\r\n\r\n\r\n\r\n\r\nfunction unwarpImage(ctx, image, corners) {\r\n  // Get perspective transform matrix\r\n  const { topLeft, topRight, bottomRight, bottomLeft } = corners;\r\n  // Compute output rectangle size\r\n  const widthA = Math.hypot(bottomRight.x - bottomLeft.x, bottomRight.y - bottomLeft.y);\r\n  const widthB = Math.hypot(topRight.x - topLeft.x, topRight.y - topLeft.y);\r\n  const maxWidth = Math.round(Math.max(widthA, widthB));\r\n  const heightA = Math.hypot(topRight.x - bottomRight.x, topRight.y - bottomRight.y);\r\n  const heightB = Math.hypot(topLeft.x - bottomLeft.x, topLeft.y - bottomLeft.y);\r\n  const maxHeight = Math.round(Math.max(heightA, heightB));\r\n\r\n  // Set output canvas size\r\n  ctx.canvas.width = maxWidth;\r\n  ctx.canvas.height = maxHeight;\r\n\r\n  const srcPoints = [\r\n    [topLeft.x, topLeft.y],\r\n    [topRight.x, topRight.y],\r\n    [bottomRight.x, bottomRight.y],\r\n    [bottomLeft.x, bottomLeft.y]\r\n  ];\r\n  const dstPoints = [\r\n    [0, 0],\r\n    [maxWidth - 1, 0],\r\n    [maxWidth - 1, maxHeight - 1],\r\n    [0, maxHeight - 1]\r\n  ];\r\n  const perspectiveMatrix = getPerspectiveTransform(srcPoints, dstPoints);\r\n  warpTransform(ctx, image, perspectiveMatrix, maxWidth, maxHeight);\r\n}\r\n\r\nfunction invert3x3(m) {\r\n  // Invert a 3x3 matrix\r\n  const a = m[0][0], b = m[0][1], c = m[0][2];\r\n  const d = m[1][0], e = m[1][1], f = m[1][2];\r\n  const g = m[2][0], h = m[2][1], i = m[2][2];\r\n  const A = e * i - f * h;\r\n  const B = -(d * i - f * g);\r\n  const C = d * h - e * g;\r\n  const D = -(b * i - c * h);\r\n  const E = a * i - c * g;\r\n  const F = -(a * h - b * g);\r\n  const G = b * f - c * e;\r\n  const H = -(a * f - c * d);\r\n  const I = a * e - b * d;\r\n  const det = a * A + b * B + c * C;\r\n  if (det === 0) throw new Error('Singular matrix');\r\n  return [\r\n    [A / det, D / det, G / det],\r\n    [B / det, E / det, H / det],\r\n    [C / det, F / det, I / det]\r\n  ];\r\n}\r\n\r\nfunction warpTransform(ctx, image, matrix, outWidth, outHeight) {\r\n  // Inverse matrix for mapping output to input\r\n  const inv = invert3x3(matrix);\r\n  // Get source image data\r\n  const srcCanvas = document.createElement('canvas');\r\n  srcCanvas.width = image.width || image.naturalWidth;\r\n  srcCanvas.height = image.height || image.naturalHeight;\r\n  const srcCtx = srcCanvas.getContext('2d');\r\n  srcCtx.drawImage(image, 0, 0, srcCanvas.width, srcCanvas.height);\r\n  const srcData = srcCtx.getImageData(0, 0, srcCanvas.width, srcCanvas.height);\r\n  const out = ctx.createImageData(outWidth, outHeight);\r\n  for (let y = 0; y < outHeight; y++) {\r\n    for (let x = 0; x < outWidth; x++) {\r\n      // Map (x, y) in output to (srcX, srcY) in input\r\n      const denom = inv[2][0] * x + inv[2][1] * y + inv[2][2];\r\n      const srcX = (inv[0][0] * x + inv[0][1] * y + inv[0][2]) / denom;\r\n      const srcY = (inv[1][0] * x + inv[1][1] * y + inv[1][2]) / denom;\r\n      // Bilinear sample\r\n      const sx = Math.max(0, Math.min(srcCanvas.width - 2, srcX));\r\n      const sy = Math.max(0, Math.min(srcCanvas.height - 2, srcY));\r\n      const ix = Math.floor(sx), iy = Math.floor(sy);\r\n      const dx = sx - ix, dy = sy - iy;\r\n      for (let c = 0; c < 4; c++) {\r\n        // Bilinear interpolation\r\n        const i00 = srcData.data[(iy * srcCanvas.width + ix) * 4 + c];\r\n        const i10 = srcData.data[(iy * srcCanvas.width + (ix + 1)) * 4 + c];\r\n        const i01 = srcData.data[((iy + 1) * srcCanvas.width + ix) * 4 + c];\r\n        const i11 = srcData.data[((iy + 1) * srcCanvas.width + (ix + 1)) * 4 + c];\r\n        out.data[(y * outWidth + x) * 4 + c] =\r\n          (1 - dx) * (1 - dy) * i00 +\r\n          dx * (1 - dy) * i10 +\r\n          (1 - dx) * dy * i01 +\r\n          dx * dy * i11;\r\n      }\r\n    }\r\n  }\r\n  ctx.putImageData(out, 0, 0);\r\n}\r\n\r\n\r\n/**\r\n * Extract document with manual corner points (no detection).\r\n * Use this when you already have the corner points (e.g., from user selection in an image editor).\r\n *\r\n * @param {HTMLImageElement|HTMLCanvasElement|ImageData} image - The source image\r\n * @param {Object} corners - Corner points defining the document quadrilateral\r\n * @param {Object} corners.topLeft - Top-left corner {x, y}\r\n * @param {Object} corners.topRight - Top-right corner {x, y}\r\n * @param {Object} corners.bottomRight - Bottom-right corner {x, y}\r\n * @param {Object} corners.bottomLeft - Bottom-left corner {x, y}\r\n * @param {Object} [options={}] - Extraction options\r\n * @param {string} [options.output='canvas'] - Output format: 'canvas', 'imagedata', or 'dataurl'\r\n * @returns {Promise<{output: (HTMLCanvasElement|ImageData|string|null), corners: Object, success: boolean, message: string}>}\r\n *\r\n * @example\r\n * const corners = {\r\n *   topLeft: { x: 100, y: 50 },\r\n *   topRight: { x: 400, y: 60 },\r\n *   bottomRight: { x: 390, y: 300 },\r\n *   bottomLeft: { x: 110, y: 290 }\r\n * };\r\n * const result = await extractDocument(img, corners);\r\n * if (result.success) {\r\n *   document.body.appendChild(result.output);\r\n * }\r\n */\r\nexport async function extractDocument(image, corners, options = {}) {\r\n  const outputType = options.output || 'canvas';\r\n\r\n  if (!corners || !corners.topLeft || !corners.topRight || !corners.bottomRight || !corners.bottomLeft) {\r\n    return {\r\n      output: null,\r\n      corners: null,\r\n      success: false,\r\n      message: 'Invalid corner points provided'\r\n    };\r\n  }\r\n\r\n  try {\r\n    // Create result canvas and extract document\r\n    const resultCanvas = document.createElement('canvas');\r\n    const ctx = resultCanvas.getContext('2d');\r\n    unwarpImage(ctx, image, corners);\r\n\r\n    let output;\r\n    // Prepare output in requested format\r\n    if (outputType === 'canvas') {\r\n      output = resultCanvas;\r\n    } else if (outputType === 'imagedata') {\r\n      output = resultCanvas.getContext('2d').getImageData(0, 0, resultCanvas.width, resultCanvas.height);\r\n    } else if (outputType === 'dataurl') {\r\n      output = resultCanvas.toDataURL();\r\n    } else {\r\n      output = resultCanvas;\r\n    }\r\n\r\n    return {\r\n      output,\r\n      corners,\r\n      success: true,\r\n      message: 'Document extracted successfully'\r\n    };\r\n  } catch (error) {\r\n    return {\r\n      output: null,\r\n      corners,\r\n      success: false,\r\n      message: `Extraction failed: ${error.message}`\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Main entry point for document scanning.\r\n * Detects and optionally extracts documents from images with automatic contour detection.\r\n *\r\n * @param {HTMLImageElement|HTMLCanvasElement|ImageData} image - The source image to scan\r\n * @param {Object} [options={}] - Scanning options\r\n * @param {string} [options.mode='detect'] - Operation mode: 'detect' (find corners only) or 'extract' (warp document)\r\n * @param {string} [options.output='canvas'] - Output format: 'canvas', 'imagedata', or 'dataurl'\r\n * @param {boolean} [options.debug=false] - Enable debug information\r\n * @param {number} [options.maxProcessingDimension=800] - Maximum image dimension for processing\r\n * @param {number} [options.lowThreshold=75] - Lower threshold for Canny edge detection\r\n * @param {number} [options.highThreshold=200] - Upper threshold for Canny edge detection\r\n * @param {number} [options.dilationKernelSize=3] - Kernel size for edge dilation\r\n * @param {number} [options.dilationIterations=1] - Number of dilation iterations\r\n * @param {number} [options.minArea=1000] - Minimum contour area to consider as document\r\n * @param {number} [options.epsilon] - Epsilon for polygon approximation\r\n * @returns {Promise<{output: (HTMLCanvasElement|ImageData|string|null), corners: Object|null, contour: Array|null, debug: Object|null, success: boolean, message: string}>}\r\n *\r\n * @example\r\n * // Detect document (returns corners only)\r\n * const detection = await scanDocument(img, { mode: 'detect' });\r\n * if (detection.success) {\r\n *   console.log('Found at:', detection.corners);\r\n * }\r\n *\r\n * @example\r\n * // Extract with perspective correction\r\n * const extracted = await scanDocument(img, { mode: 'extract', output: 'canvas' });\r\n */\r\nexport async function scanDocument(image, options = {}) {\r\n  const mode = options.mode || 'detect';\r\n  const outputType = options.output || 'canvas';\r\n  const debug = !!options.debug;\r\n\r\n  // Prepare input image data\r\n  let imageData, width, height;\r\n  if (image instanceof ImageData) {\r\n    imageData = image;\r\n    width = image.width;\r\n    height = image.height;\r\n  } else {\r\n    // HTMLImageElement or HTMLCanvasElement\r\n    const tempCanvas = document.createElement('canvas');\r\n    tempCanvas.width = image.width || image.naturalWidth;\r\n    tempCanvas.height = image.height || image.naturalHeight;\r\n    const tempCtx = tempCanvas.getContext('2d');\r\n    tempCtx.drawImage(image, 0, 0, tempCanvas.width, tempCanvas.height);\r\n    imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);\r\n    width = tempCanvas.width;\r\n    height = tempCanvas.height;\r\n  }\r\n\r\n  // Detect document\r\n  const detection = await detectDocumentInternal(imageData, options);\r\n  if (!detection.success) {\r\n    return {\r\n      output: null,\r\n      corners: null,\r\n      contour: null,\r\n      debug: detection.debug,\r\n      success: false,\r\n      message: detection.message || 'No document detected'\r\n    };\r\n  }\r\n\r\n  let resultCanvas;\r\n  let output;\r\n\r\n  if (mode === 'detect') {\r\n    // Just return detection info, no image processing\r\n    output = null;\r\n  } else if (mode === 'extract') {\r\n    // Return only the cropped/warped document\r\n    resultCanvas = document.createElement('canvas');\r\n    const ctx = resultCanvas.getContext('2d');\r\n    unwarpImage(ctx, image, detection.corners);\r\n  }\r\n\r\n  // Prepare output in requested format (only if not detect mode)\r\n  if (mode !== 'detect' && resultCanvas) {\r\n    if (outputType === 'canvas') {\r\n      output = resultCanvas;\r\n    } else if (outputType === 'imagedata') {\r\n      output = resultCanvas.getContext('2d').getImageData(0, 0, resultCanvas.width, resultCanvas.height);\r\n    } else if (outputType === 'dataurl') {\r\n      output = resultCanvas.toDataURL();\r\n    } else {\r\n      output = resultCanvas;\r\n    }\r\n  }\r\n\r\n  return {\r\n    output,\r\n    corners: detection.corners,\r\n    contour: detection.contour,\r\n    debug: detection.debug,\r\n    success: true,\r\n    message: 'Document detected'\r\n  };\r\n}\r\n\r\n// Export enhanced detection functions\r\nexport {\r\n  enhancedDocumentDetection,\r\n  quickDocumentDetection,\r\n  detectIDDocument,\r\n  enhancedEdgeDetection,\r\n  detectDocumentHough,\r\n  DETECTION_PRESETS,\r\n} from './enhancedDetection.js';"],"names":["DEFAULTS","RETR_EXTERNAL","RETR_LIST","CHAIN_APPROX_SIMPLE","deltas","detectDocumentContour","edges","options","width","height","mode","method","minArea","paddedWidth","paddedHeight","labels","y","x","contours","nextContourId","currentPixelLabel","leftPixelLabel","startPoint","isOuter","initialDirection","contourId","points","traceContour","finalPoints","simplifyChainApproxSimple","adjustedPoints","p","contour","calculateContourArea","calculateBoundingBox","filteredContours","a","b","visitedPoints","currentPoint","prevDirection","count","maxSteps","searchDirection","found","i","nextX","nextY","nextPoint","checkDirection","checkX","checkY","pointKey","simplifiedPoints","n","prevPoint","dx1","dy1","dx2","dy2","maxDistSq","farthestIdx","p0","pi","distSq","area","j","minX","minY","maxX","maxY","point","simplifyContour","epsilon","maxDistance","index","firstPoint","lastPoint","distance","perpendicularDistance","firstSegment","secondSegment","lineStart","lineEnd","dx","dy","lineLengthSq","t","closestPointX","closestPointY","distDx","distDy","approximatePolygon","contourPoints","perimeter","calculateContourPerimeter","actualEpsilon","findCenter","sumX","sumY","findCornerPoints","approximation","corners","orderCornerPoints","findCornersByCoordinateExtremes","topLeft","topRight","bottomRight","bottomLeft","minSum","maxDiff","maxSum","minDiff","sum","diff","center","sortedPoints","angleA","angleB","minIndex","orderedPoints","wasm","cachedFloat32ArrayMemory0","getFloat32ArrayMemory0","WASM_VECTOR_LEN","passArrayF32ToWasm0","arg","malloc","ptr","getArrayF32FromWasm0","len","find_document_quadrilateral","lines","min_area_ratio","max_area_ratio","ptr0","len0","ret","v2","cachedUint8ArrayMemory0","getUint8ArrayMemory0","passArray8ToWasm0","hough_lines","rho_resolution","theta_resolution","threshold","max_lines","getArrayU8FromWasm0","close_edge_gaps","gap_size","remove_small_components","binary","min_area","thin_edges","compute_adaptive_canny_thresholds","magnitude","_width","_height","low_ratio","high_ratio","otsu_threshold","input","clahe","tile_grid_x","tile_grid_y","clip_limit","contrast_stretch","illumination_normalize","sigma","blur","grayscale","kernel_size","cachedUint16ArrayMemory0","getUint16ArrayMemory0","passArray16ToWasm0","refine_corners_subpixel","gradients","search_radius","ptr1","len1","v3","calculate_size_score","image_width","image_height","min_coverage","max_coverage","ideal_coverage","validate_quadrilateral","calculate_detection_confidence","edge_score","shape_score","aspect_score","size_score","calculate_edge_strength","sample_points","cachedInt16ArrayMemory0","getInt16ArrayMemory0","getArrayI16FromWasm0","non_maximum_suppression","l2_gradient","dilate","nms_precise","direction","sobel_gradients_3x3","sobel_gradients_3x3_simd","sobel_gradients_5x5","gradient_magnitude_direction","l2_norm","scharr_gradients_3x3","hysteresis_thresholding","suppressed","low_threshold","high_threshold","__wbg_load","module","imports","e","bytes","instance","__wbg_get_imports","table","offset","__wbg_finalize_init","__wbg_init","module_or_path","wasmReady","init","convertToGrayscale","imageData","data","gaussianBlurGrayscale","kernelSize","halfKernel","kernel","createGaussianKernel","tempArray","blurred","rowOffset","k","xOffset","yOffset","size","halfSize","calculateGradients","prevRowOffset","nextRowOffset","currentIdx","p1","p2","p3","p5","p6","p7","p8","gx","gy","nonMaximumSuppression","L2gradient","idx","mag","neighbor1","neighbor2","absGx","absGy","s","hysteresisThresholding","lowThreshold","highThreshold","edgeMap","stack","dxNeighbors","dyNeighbors","nx","ny","nidx","dilateEdges","temp","dilated","maxVal","val","cannyEdgeDetector","timings","tStart","applyDilation","dilationKernelSize","useWasmHysteresis","t0","t1","wasmBlur","wasmMaximumSuppression","finalLowThreshold","finalHighThreshold","wasmHysteresis","cannyEdges","finalEdges","wasmDilate","tEnd","DETECTION_PRESETS","preprocessImage","processed","wasmIlluminationNormalize","wasmClahe","wasmContrastStretch","operator","wasmScharr3x3","wasmSobel5x5","wasmSobel3x3Simd","wasmSobel3x3","elapsed","computeAdaptiveThresholds","magnitudeU8","maxMag","otsuThresh","wasmOtsuThreshold","thresholds","wasmComputeCannyThresholds","enhancedEdgeDetection","config","preprocessing","edgeConfig","postConfig","debug","prepTimings","gradientTime","magDir","wasmGradientMagDir","wasmNmsPrecise","adaptive","performHysteresis","postProcessed","wasmCloseEdgeGaps","wasmRemoveSmallComponents","wasmThinEdges","output","visited","offsets","detectDocumentHough","wasmHoughLines","numLines","quad","wasmFindQuadrilateral","parseLines","lineConfidence","validation","wasmValidateQuadrilateral","validationResult","sizeScore","wasmCalculateSizeScore","confidence","wasmCalculateConfidence","result","enhancedDocumentDetection","preset","mergedConfig","edgeResult","detection","cornersArray","edgeScore","wasmCalculateEdgeStrength","refined","wasmRefineCorners","quickDocumentDetection","detectIDDocument","calculateAdaptiveDownscale","maxDimension","maxCurrentDimension","scaleFactor","scaledWidth","scaledHeight","tempCanvas","scaledCanvas","scaledCtx","detectDocumentInternal","debugInfo","maxProcessingDimension","scaledImageData","originalDimensions","scaledDimensions","documentContour","cornerPoints","finalCorners","getPerspectiveTransform","srcPoints","dstPoints","buildMatrix","matrix","A","solve","m","M","row","B","maxRow","h","unwarpImage","ctx","image","widthA","widthB","maxWidth","heightA","heightB","maxHeight","perspectiveMatrix","warpTransform","invert3x3","c","d","f","g","C","D","E","F","G","H","I","det","outWidth","outHeight","inv","srcCanvas","srcCtx","srcData","out","denom","srcX","srcY","sx","sy","ix","iy","i00","i10","i01","i11","extractDocument","outputType","resultCanvas","error","scanDocument","tempCtx"],"mappings":"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"}