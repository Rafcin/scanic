{"version":3,"file":"scanic.umd.cjs","sources":["../src/constants.js","../src/contourDetection.js","../src/cornerDetection.js","../wasm_blur/pkg/wasm_blur.js","../src/edgeDetection.js","../src/enhancedDetection.js","../src/index.js"],"sourcesContent":["/**\r\n * Constants used throughout the library\r\n */\r\n\r\nexport const VERSION = '1.0.0';\r\n\r\nexport const DEFAULTS = {\r\n  // Edge detection params\r\n  GAUSSIAN_SIGMA: 1.1,\r\n  LOW_THRESHOLD: 50,\r\n  HIGH_THRESHOLD: 150,\r\n  \r\n  // Contour detection params\r\n  MIN_CONTOUR_AREA: 1000,\r\n  MIN_CONTOUR_POINTS: 10,\r\n  \r\n  // Debug options\r\n  DEBUG_OVERLAY_OPACITY: 0.7\r\n};","/**\r\n * Pure JavaScript implementation of contour detection algorithms\r\n * Based on Suzuki, S. and Abe, K. (1985). Topological structural analysis of digitized binary images by border following.\r\n * Replaces the previous flood-fill based connected components analysis.\r\n */\r\n\r\nimport { DEFAULTS } from './constants.js';\r\n\r\n// Constants for different retrieval modes (subset of OpenCV)\r\nconst RETR_EXTERNAL = 0;\r\nconst RETR_LIST = 1;\r\n// Constants for different approximation methods (subset of OpenCV)\r\nconst CHAIN_APPROX_NONE = 1;\r\nconst CHAIN_APPROX_SIMPLE = 2;\r\n\r\n// Deltas for 8-connectivity neighborhood checks (0-7 clockwise from top)\r\n// Corresponds to OpenCV's chain code directions\r\nconst deltas = [\r\n  { dx:  0, dy: -1 }, // 0: Top\r\n  { dx:  1, dy: -1 }, // 1: Top-right\r\n  { dx:  1, dy:  0 }, // 2: Right\r\n  { dx:  1, dy:  1 }, // 3: Bottom-right\r\n  { dx:  0, dy:  1 }, // 4: Bottom\r\n  { dx: -1, dy:  1 }, // 5: Bottom-left\r\n  { dx: -1, dy:  0 }, // 6: Left\r\n  { dx: -1, dy: -1 }  // 7: Top-left\r\n];\r\n\r\n/**\r\n * Detects contours in a binary edge image using Suzuki's border following algorithm.\r\n * @param {Uint8ClampedArray} edges - Binary edge image (pixels > 0 are foreground)\r\n * @param {Object} options - Configuration options\r\n * @param {number} [options.width] - Image width (required if not square)\r\n * @param {number} [options.height] - Image height (required if not square)\r\n * @param {number} [options.mode=RETR_LIST] - Contour retrieval mode (RETR_EXTERNAL or RETR_LIST)\r\n * @param {number} [options.method=CHAIN_APPROX_SIMPLE] - Contour approximation method (CHAIN_APPROX_NONE or CHAIN_APPROX_SIMPLE)\r\n * @param {number} [options.minArea=DEFAULTS.MIN_CONTOUR_AREA] - Minimum contour area filter (applied after detection)\r\n * @param {Object} [options.debug] - Optional debug object to store intermediate results\r\n * @returns {Array} Array of contours, each contour is an array of points {x, y}. Sorted by area (largest first).\r\n */\r\nexport function detectDocumentContour(edges, options = {}) {\r\n  const width = options.width || Math.sqrt(edges.length);\r\n  const height = options.height || edges.length / width;\r\n  const mode = options.mode !== undefined ? options.mode : RETR_LIST;\r\n  const method = options.method !== undefined ? options.method : CHAIN_APPROX_SIMPLE;\r\n  const minArea = options.minArea || DEFAULTS.MIN_CONTOUR_AREA;\r\n\r\n  // Create a padded label map to simplify boundary checks.\r\n  // 0: background\r\n  // 1: foreground (unlabeled)\r\n  // >= 2: contour ID (2, 3, ...)\r\n  const paddedWidth = width + 2;\r\n  const paddedHeight = height + 2;\r\n  const labels = new Int32Array(paddedWidth * paddedHeight); // Initialized to 0\r\n\r\n  // Copy edges data to the label map, mapping foreground pixels to 1\r\n  for (let y = 0; y < height; y++) {\r\n    for (let x = 0; x < width; x++) {\r\n      if (edges[y * width + x] > 0) {\r\n        labels[(y + 1) * paddedWidth + (x + 1)] = 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  const contours = [];\r\n  let nextContourId = 2; // Start labeling contours from 2\r\n\r\n  // Raster scan\r\n  for (let y = 1; y <= height; y++) {\r\n    for (let x = 1; x <= width; x++) {\r\n      const currentPixelLabel = labels[y * paddedWidth + x];\r\n      const leftPixelLabel = labels[y * paddedWidth + (x - 1)];\r\n\r\n      let startPoint = null;\r\n      let isOuter = false;\r\n      let initialDirection = -1;\r\n\r\n      if (currentPixelLabel === 1 && leftPixelLabel === 0) {\r\n        // Found the start of an outer contour boundary (NBD = 1 in Suzuki's terms)\r\n        isOuter = true;\r\n        startPoint = { x: x, y: y };\r\n        initialDirection = 2; // Start searching right\r\n        // if (options.debug) console.log(`Outer contour start at (${x-1}, ${y-1})`);\r\n      } else if (currentPixelLabel === 0 && leftPixelLabel >= 1 && leftPixelLabel !== -1) {\r\n         // Found the start of a hole contour boundary (NBD >= 2 in Suzuki's terms)\r\n         // Check if the left pixel is already part of a traced contour border\r\n         // If leftPixelLabel is > 1, it might be already traced. If it's 1, it's an unlabeled foreground pixel.\r\n         // We only start tracing if the left pixel is unlabeled foreground (1).\r\n         if (leftPixelLabel === 1) {\r\n             isOuter = false;\r\n             startPoint = { x: x - 1, y: y };\r\n             initialDirection = 6; // Start searching left\r\n            //  if (options.debug) console.log(`Hole contour start at (${x-1-1}, ${y-1})`);\r\n         }\r\n      }\r\n\r\n\r\n      if (startPoint) {\r\n        // If mode is RETR_EXTERNAL, only process outer contours\r\n        if (mode === RETR_EXTERNAL && !isOuter) {\r\n          // Mark the starting pixel of the hole so we don't process it again\r\n          // Use a special marker (-1) to distinguish from contour IDs\r\n           labels[startPoint.y * paddedWidth + startPoint.x] = -1;\r\n           continue;\r\n        }\r\n\r\n        const contourId = nextContourId++;\r\n        const points = traceContour(labels, paddedWidth, paddedHeight, startPoint, initialDirection, contourId);\r\n\r\n        if (points && points.length > 0) {\r\n            let finalPoints = points;\r\n            if (method === CHAIN_APPROX_SIMPLE) {\r\n                finalPoints = simplifyChainApproxSimple(points);\r\n            }\r\n\r\n            // Adjust points to original image coordinates (remove padding offset)\r\n            const adjustedPoints = finalPoints.map(p => ({ x: p.x - 1, y: p.y - 1 }));\r\n\r\n            if (adjustedPoints.length >= (method === CHAIN_APPROX_SIMPLE ? 4 : DEFAULTS.MIN_CONTOUR_POINTS)) { // Need at least 4 points for a simple polygon approx\r\n                const contour = {\r\n                    id: contourId,\r\n                    points: adjustedPoints,\r\n                    isOuter: isOuter,\r\n                    // Calculate area and bounding box later if needed for filtering/sorting\r\n                };\r\n                contours.push(contour);\r\n            }\r\n        } else {\r\n             // Handle single point contours or errors if necessary\r\n             // Mark the start point if trace failed or resulted in no points\r\n             if (labels[startPoint.y * paddedWidth + startPoint.x] === 1) {\r\n                 labels[startPoint.y * paddedWidth + startPoint.x] = contourId; // Mark as visited\r\n             }\r\n        }\r\n      } else if (currentPixelLabel >= 1 && leftPixelLabel >= 1 && currentPixelLabel !== leftPixelLabel) {\r\n          // Handle merging contours or complex topology if needed (not implemented for RETR_LIST/EXTERNAL)\r\n      }\r\n    }\r\n  }\r\n\r\n  // Calculate area and bounding box for filtering and sorting\r\n  contours.forEach(contour => {\r\n    contour.area = calculateContourArea(contour.points);\r\n    contour.boundingBox = calculateBoundingBox(contour.points);\r\n  });\r\n\r\n  // Filter by minimum area\r\n  const filteredContours = contours.filter(contour => contour.area >= minArea);\r\n\r\n  // Sort contours by area (largest first)\r\n  filteredContours.sort((a, b) => b.area - a.area);\r\n\r\n  // console.log(`Found ${contours.length} contours before filtering, ${filteredContours.length} after filtering.`);\r\n\r\n  // Store debug info if requested\r\n  if (options.debug) {\r\n    options.debug.labels = labels; // Store the final label map\r\n    options.debug.rawContours = contours; // Store contours before filtering/sorting\r\n    options.debug.finalContours = filteredContours;\r\n    // console.log('Contour detection debug info stored');\r\n  }\r\n  return filteredContours // Return only the points array per contour\r\n}\r\n\r\n/**\r\n * Traces a contour boundary using border following.\r\n * @param {Int32Array} labels - The label map (modified during tracing)\r\n * @param {number} width - Padded width of the label map\r\n * @param {number} height - Padded height of the label map\r\n * @param {Object} startPoint - Starting point {x, y} in padded coordinates\r\n * @param {number} initialDirection - Initial search direction (0-7)\r\n * @param {number} contourId - The ID to label this contour with\r\n * @returns {Array} Array of points {x, y} in padded coordinates, or null if error\r\n */\r\nfunction traceContour(labels, width, height, startPoint, initialDirection, contourId) {\r\n    const points = [];\r\n    const visitedPoints = new Set(); // Use a Set for efficient duplicate checking\r\n    let currentPoint = { ...startPoint };\r\n    let prevDirection = -1; // Store the direction from which we arrived at currentPoint\r\n\r\n    // Mark the starting pixel with the contour ID\r\n    labels[startPoint.y * width + startPoint.x] = contourId;\r\n\r\n    let count = 0; // Safety break\r\n    const maxSteps = width * height; // Max possible steps\r\n\r\n    while (count++ < maxSteps) {\r\n        // Determine the direction to start searching from (relative to the direction we came from)\r\n        // In Suzuki's paper, this is based on the chain code of the previous step.\r\n        // Simplified: Start searching from the direction after the one that led us here.\r\n        // If we arrived from direction `d`, the next pixel must be in `(d+1)%8` to `(d+7)%8`.\r\n        // Let's adapt OpenCV's logic: search starts from (prevDirection + 2) % 8 clockwise.\r\n        // If it's the first step, prevDirection is unknown, use initialDirection logic.\r\n\r\n        let searchDirection;\r\n        if (prevDirection === -1) {\r\n            // First step: Use initialDirection logic (e.g., start right for outer, left for inner)\r\n            // The initial search should find the *first* pixel of the contour boundary clockwise.\r\n            // Let's refine the initial search based on OpenCV's approach:\r\n            // Find the first non-zero pixel starting from `initialDirection` clockwise.\r\n            let found = false;\r\n            for (let i = 0; i < 8; i++) {\r\n                searchDirection = (initialDirection + i) % 8;\r\n                const nextX = currentPoint.x + deltas[searchDirection].dx;\r\n                const nextY = currentPoint.y + deltas[searchDirection].dy;\r\n                if (nextX >= 0 && nextX < width && nextY >= 0 && nextY < height && labels[nextY * width + nextX] > 0) {\r\n                    found = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!found) return null; // Should not happen if startPoint is valid\r\n\r\n        } else {\r\n            // Subsequent steps: Start search from (prevDirection + 2) % 8 clockwise\r\n             searchDirection = (prevDirection + 2) % 8;\r\n        }\r\n\r\n\r\n        let nextPoint = null;\r\n        let nextDirection = -1;\r\n\r\n        // Search clockwise for the next boundary pixel\r\n        for (let i = 0; i < 8; i++) {\r\n            const checkDirection = (searchDirection + i) % 8;\r\n            const checkX = currentPoint.x + deltas[checkDirection].dx;\r\n            const checkY = currentPoint.y + deltas[checkDirection].dy;\r\n\r\n            // Check bounds (should be within padded area)\r\n            if (checkX >= 0 && checkX < width && checkY >= 0 && checkY < height) {\r\n                const pixelLabel = labels[checkY * width + checkX];\r\n                if (pixelLabel > 0) { // Found a foreground pixel (labeled or unlabeled)\r\n                    nextPoint = { x: checkX, y: checkY };\r\n                    // The direction *from* currentPoint *to* nextPoint is checkDirection\r\n                    nextDirection = checkDirection;\r\n                    // The direction *from* which we will arrive *at* nextPoint is (checkDirection + 4) % 8\r\n                    prevDirection = (checkDirection + 4) % 8;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!nextPoint) {\r\n            // Should not happen in a well-formed contour, maybe isolated pixel?\r\n             if (points.length === 0) { // If it's just the start point\r\n                 points.push({ ...currentPoint }); // Add the single point\r\n             }\r\n            console.warn(`Contour tracing stopped unexpectedly at (${currentPoint.x-1}, ${currentPoint.y-1}) for contour ${contourId}`);\r\n            break;\r\n        }\r\n\r\n        // Add the *current* point to the list before moving\r\n        const pointKey = `${currentPoint.x},${currentPoint.y}`;\r\n        if (visitedPoints.has(pointKey)) {\r\n            // console.warn(`Duplicate point detected at (${currentPoint.x}, ${currentPoint.y}) for contour ${contourId}`);\r\n            // console.warn(points)\r\n            // console.warn(filtered)\r\n            return points; // Avoid infinite loops on duplicate points\r\n        }\r\n        points.push({ ...currentPoint });\r\n        visitedPoints.add(pointKey);\r\n        \r\n\r\n        // Mark the next pixel if it's unlabeled\r\n        if (labels[nextPoint.y * width + nextPoint.x] === 1) {\r\n            labels[nextPoint.y * width + nextPoint.x] = contourId;\r\n        }\r\n\r\n        // Move to the next point\r\n        currentPoint = nextPoint;\r\n\r\n        // Check if we returned to the start point\r\n        if (currentPoint.x === startPoint.x && currentPoint.y === startPoint.y) {\r\n            // Check if we came from the same direction as the initial step search ended.\r\n            // This is complex, let's use a simpler check: if we are back at start, we are done.\r\n            // OpenCV has more sophisticated checks involving i4 == i0 && i3 == i1.\r\n            break;\r\n        }\r\n    }\r\n\r\n     if (count >= maxSteps) {\r\n        console.warn(`Contour tracing exceeded max steps for contour ${contourId}`);\r\n        return null; // Indicate potential error\r\n    }\r\n\r\n    return points;\r\n}\r\n\r\n/**\r\n * Simplifies a contour polygon using CHAIN_APPROX_SIMPLE.\r\n * Removes intermediate points that lie on the straight line segment between their neighbors.\r\n * @param {Array} points - Array of contour points {x, y}\r\n * @returns {Array} Simplified array of points\r\n */\r\nfunction simplifyChainApproxSimple(points) {\r\n    if (points.length <= 2) {\r\n        return points;\r\n    }\r\n\r\n    const simplifiedPoints = [];\r\n    const n = points.length;\r\n\r\n    for (let i = 0; i < n; i++) {\r\n        const prevPoint = points[(i + n - 1) % n]; // Handle wrap around\r\n        const currentPoint = points[i];\r\n        const nextPoint = points[(i + 1) % n]; // Handle wrap around\r\n\r\n        // Check for collinearity: (y2-y1)*(x3-x2) == (y3-y2)*(x2-x1)\r\n        const dx1 = currentPoint.x - prevPoint.x;\r\n        const dy1 = currentPoint.y - prevPoint.y;\r\n        const dx2 = nextPoint.x - currentPoint.x;\r\n        const dy2 = nextPoint.y - currentPoint.y;\r\n\r\n        // If points are not collinear, keep the current point\r\n        if (dx1 * dy2 !== dy1 * dx2) {\r\n            simplifiedPoints.push(currentPoint);\r\n        }\r\n    }\r\n\r\n    // Handle cases where all points are collinear (e.g., straight line)\r\n    // In this case, the above loop might remove all points. Keep first and last?\r\n    // OpenCV keeps the two endpoints of the line segment.\r\n    if (simplifiedPoints.length === 0 && n > 0) {\r\n         // If all points were collinear, return the start and end points of the original sequence\r\n         // This requires knowing the original start/end, which isn't trivial with wrap-around.\r\n         // Let's return the first and the point furthest from the first.\r\n         if (n === 1) return [points[0]];\r\n         if (n === 2) return points;\r\n\r\n         // Find the point most distant from the first point to represent the line segment\r\n         let maxDistSq = 0;\r\n         let farthestIdx = 1;\r\n         const p0 = points[0];\r\n         for(let i = 1; i < n; i++) {\r\n             const pi = points[i];\r\n             const distSq = (pi.x - p0.x)**2 + (pi.y - p0.y)**2;\r\n             if (distSq > maxDistSq) {\r\n                 maxDistSq = distSq;\r\n                 farthestIdx = i;\r\n             }\r\n         }\r\n         // Ensure order if needed, but for simple approx, just two points is fine.\r\n         return [points[0], points[farthestIdx]];\r\n    }\r\n\r\n\r\n    return simplifiedPoints;\r\n}\r\n\r\n\r\n// --- Helper functions (keep or adapt from original) ---\r\n\r\n/**\r\n * Calculates the area of a contour using the shoelace formula\r\n * @param {Array} points - Array of point coordinates {x, y}\r\n * @returns {number} Contour area\r\n */\r\nfunction calculateContourArea(points) {\r\n  let area = 0;\r\n  const n = points.length;\r\n\r\n  if (n < 3) return 0;\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    const j = (i + 1) % n;\r\n    area += points[i].x * points[j].y;\r\n    area -= points[j].x * points[i].y;\r\n  }\r\n\r\n  return Math.abs(area) / 2;\r\n}\r\n\r\n/**\r\n * Calculates the bounding box of a contour\r\n * @param {Array} points - Array of point coordinates\r\n * @returns {Object} Bounding box with minX, minY, maxX, maxY properties\r\n */\r\nfunction calculateBoundingBox(points) {\r\n  if (points.length === 0) {\r\n      return { minX: 0, minY: 0, maxX: 0, maxY: 0 };\r\n  }\r\n  let minX = points[0].x;\r\n  let minY = points[0].y;\r\n  let maxX = points[0].x;\r\n  let maxY = points[0].y;\r\n\r\n  for (let i = 1; i < points.length; i++) {\r\n      const point = points[i];\r\n      minX = Math.min(minX, point.x);\r\n      minY = Math.min(minY, point.y);\r\n      maxX = Math.max(maxX, point.x);\r\n      maxY = Math.max(maxY, point.y);\r\n  }\r\n\r\n  return { minX, minY, maxX, maxY };\r\n}\r\n\r\n\r\n// --- Functions below are no longer directly used by detectDocumentContour ---\r\n// --- but might be useful elsewhere or can be removed ---\r\n\r\n/**\r\n * Simplifies a contour using the Ramer-Douglas-Peucker algorithm\r\n * (No longer used by default contour detection, kept for potential external use)\r\n * @param {Array} points - Array of point coordinates\r\n * @param {number} epsilon - Epsilon value for simplification\r\n * @returns {Array} Simplified contour points\r\n */\r\nexport function simplifyContour(points, epsilon = 1.0) {\r\n  // ... (keep existing implementation if needed elsewhere) ...\r\n   if (points.length <= 2) {\r\n    return points;\r\n  }\r\n\r\n  // Find point with the maximum distance\r\n  let maxDistance = 0;\r\n  let index = 0;\r\n\r\n  const firstPoint = points[0];\r\n  const lastPoint = points[points.length - 1];\r\n\r\n  for (let i = 1; i < points.length - 1; i++) {\r\n    const distance = perpendicularDistance(points[i], firstPoint, lastPoint);\r\n\r\n    if (distance > maxDistance) {\r\n      maxDistance = distance;\r\n      index = i;\r\n    }\r\n  }\r\n\r\n  // If max distance is greater than epsilon, recursively simplify\r\n  if (maxDistance > epsilon) {\r\n    // Recursive simplification\r\n    const firstSegment = simplifyContour(points.slice(0, index + 1), epsilon);\r\n    const secondSegment = simplifyContour(points.slice(index), epsilon);\r\n\r\n    // Concatenate the two segments\r\n    return firstSegment.slice(0, -1).concat(secondSegment);\r\n  } else {\r\n    // Return just the endpoints\r\n    return [firstPoint, lastPoint];\r\n  }\r\n}\r\n\r\n/**\r\n * Calculates the perpendicular distance from a point to a line\r\n * (Helper for RDP simplifyContour, keep if that function is kept)\r\n * @param {Object} point - Point to measure from\r\n * @param {Object} lineStart - Start point of the line\r\n * @param {Object} lineEnd - End point of the line\r\n * @returns {number} Perpendicular distance\r\n */\r\nfunction perpendicularDistance(point, lineStart, lineEnd) {\r\n // ... (keep existing implementation if needed elsewhere) ...\r\n   const dx = lineEnd.x - lineStart.x;\r\n  const dy = lineEnd.y - lineStart.y;\r\n\r\n  // Line length squared\r\n  const lineLengthSq = dx * dx + dy * dy;\r\n\r\n  if (lineLengthSq === 0) {\r\n    // Point to point distance if the line has zero length\r\n    return Math.sqrt(\r\n      Math.pow(point.x - lineStart.x, 2) +\r\n      Math.pow(point.y - lineStart.y, 2)\r\n    );\r\n  }\r\n\r\n   // Calculate the projection parameter t\r\n  const t = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / lineLengthSq;\r\n\r\n  let closestPointX, closestPointY;\r\n\r\n  if (t < 0) {\r\n    closestPointX = lineStart.x;\r\n    closestPointY = lineStart.y;\r\n  } else if (t > 1) {\r\n    closestPointX = lineEnd.x;\r\n    closestPointY = lineEnd.y;\r\n  } else {\r\n    closestPointX = lineStart.x + t * dx;\r\n    closestPointY = lineStart.y + t * dy;\r\n  }\r\n\r\n  // Calculate the distance from the point to the closest point on the line segment\r\n  const distDx = point.x - closestPointX;\r\n  const distDy = point.y - closestPointY;\r\n  return Math.sqrt(distDx * distDx + distDy * distDy);\r\n\r\n  /* // Original implementation using area formula (distance to infinite line)\r\n  const lineLength = Math.sqrt(lineLengthSq);\r\n  const area = Math.abs(dy * point.x - dx * point.y + lineEnd.x * lineStart.y - lineEnd.y * lineStart.x);\r\n  return area / lineLength;\r\n  */\r\n}\r\n\r\n/**\r\n * Creates a polygon approximation of a contour using RDP.\r\n * (No longer used by default contour detection, kept for potential external use)\r\n * @param {Array} contourPoints - Array of points {x, y}\r\n * @param {number} epsilon - Epsilon for polygon approximation (relative to perimeter)\r\n * @returns {Array} Array of polygon points\r\n */\r\nexport function approximatePolygon(contourPoints, epsilon = 0.02) {\r\n  // Calculate contour perimeter\r\n  const perimeter = calculateContourPerimeter(contourPoints);\r\n\r\n  // Calculate epsilon based on perimeter\r\n  const actualEpsilon = epsilon * perimeter;\r\n\r\n  // Simplify the contour using RDP\r\n  const simplifiedPoints = simplifyContour(contourPoints, actualEpsilon);\r\n\r\n  return simplifiedPoints;\r\n}\r\n\r\n/**\r\n * Calculates the perimeter of a contour\r\n * (Helper for RDP approximatePolygon, keep if that function is kept)\r\n * @param {Array} points - Array of point coordinates\r\n * @returns {number} Contour perimeter\r\n */\r\nfunction calculateContourPerimeter(points) {\r\n // ... (keep existing implementation if needed elsewhere) ...\r\n   let perimeter = 0;\r\n  const n = points.length;\r\n\r\n  if (n < 2) return 0;\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    const j = (i + 1) % n; // Wrap around for the last segment\r\n    const dx = points[i].x - points[j].x;\r\n    const dy = points[i].y - points[j].y;\r\n    perimeter += Math.sqrt(dx * dx + dy * dy);\r\n  }\r\n\r\n  return perimeter;\r\n}\r\n\r\n// Flood fill is no longer used for contour detection\r\n/*\r\nfunction floodFill(edges, labels, width, height, startX, startY, label) {\r\n  // ... (original floodFill implementation removed) ...\r\n}\r\n*/","/**\r\n * Pure JavaScript implementation for detecting corners of a document\r\n * Replaces OpenCV's corner detection and point finding logic\r\n */\r\n\r\nimport { approximatePolygon } from './contourDetection.js';\r\n\r\n/**\r\n * Calculate distance between two points\r\n * @param {Object} p1 - First point {x, y}\r\n * @param {Object} p2 - Second point {x, y}\r\n * @returns {number} Distance between points\r\n */\r\nexport function distance(p1, p2) {\r\n  return Math.hypot(p2.x - p1.x, p2.y - p1.y);\r\n}\r\n\r\n/**\r\n * Find the center point of a contour\r\n * @param {Array} points - Array of contour points\r\n * @returns {Object} Center point {x, y}\r\n */\r\nfunction findCenter(points) {\r\n  let sumX = 0;\r\n  let sumY = 0;\r\n  \r\n  for (const point of points) {\r\n    sumX += point.x;\r\n    sumY += point.y;\r\n  }\r\n  \r\n  return {\r\n    x: sumX / points.length,\r\n    y: sumY / points.length\r\n  };\r\n}\r\n\r\n/**\r\n * Find the four corners of a document contour\r\n * @param {Object} contour - Contour object with points property\r\n * @param {Object} options - Configuration options\r\n * @returns {Object} Object with topLeft, topRight, bottomRight, bottomLeft corners\r\n */\r\nexport function findCornerPoints(contour, options = {}) {\r\n  if (!contour || !contour.points || contour.points.length < 4) {\r\n    console.warn('Contour does not have enough points for corner detection');\r\n    return null;\r\n  }\r\n  \r\n  // Try to find a quadrilateral approximation of the contour\r\n  const epsilon = options.epsilon || 0.02;\r\n  const approximation = approximatePolygon(contour, epsilon);\r\n  \r\n  let corners;\r\n  \r\n  // If we get exactly 4 points, we can use them as corners\r\n  if (approximation && approximation.length === 4) {\r\n    // console.log('Found 4-point approximation, using as corners');\r\n    corners = orderCornerPoints(approximation);\r\n  } else {\r\n    // console.log(`Polygon approximation gave ${approximation ? approximation.length : 'null'} points, using coordinate extremes method`);\r\n    // Fallback: Use the coordinate extremes method on the original contour points\r\n    corners = findCornersByCoordinateExtremes(contour.points); \r\n  }\r\n  \r\n  // Ensure all corners were found\r\n  if (!corners || !corners.topLeft || !corners.topRight || !corners.bottomRight || !corners.bottomLeft) {\r\n      console.warn('Failed to find all four corners.', corners);\r\n      // Return null or partial corners? Returning null might be safer downstream.\r\n      return null; \r\n  }\r\n\r\n  // Debug info\r\n  console.log('Corner points:', corners);\r\n  return corners;\r\n}\r\n\r\n/**\r\n * Find corners by finding points with min/max coordinate sums/differences.\r\n * This is an alternative heuristic for finding corners.\r\n * @param {Array} points - Array of contour points\r\n * @returns {Object} Object with topLeft, topRight, bottomRight, bottomLeft corners\r\n */\r\nfunction findCornersByCoordinateExtremes(points) {\r\n  if (!points || points.length === 0) return null;\r\n\r\n  let topLeft = points[0];      // Min sum x + y\r\n  let topRight = points[0];     // Max diff x - y\r\n  let bottomRight = points[0];  // Max sum x + y\r\n  let bottomLeft = points[0];   // Min diff x - y\r\n\r\n  let minSum = topLeft.x + topLeft.y;\r\n  let maxDiff = topRight.x - topRight.y;\r\n  let maxSum = bottomRight.x + bottomRight.y;\r\n  let minDiff = bottomLeft.x - bottomLeft.y;\r\n\r\n  for (let i = 1; i < points.length; i++) {\r\n    const point = points[i];\r\n    const sum = point.x + point.y;\r\n    const diff = point.x - point.y;\r\n\r\n    // Top-Left (min sum)\r\n    if (sum < minSum) {\r\n      minSum = sum;\r\n      topLeft = point;\r\n    }\r\n    // Bottom-Right (max sum)\r\n    if (sum > maxSum) {\r\n      maxSum = sum;\r\n      bottomRight = point;\r\n    }\r\n    // Top-Right (max diff)\r\n    if (diff > maxDiff) {\r\n      maxDiff = diff;\r\n      topRight = point;\r\n    }\r\n    // Bottom-Left (min diff)\r\n    if (diff < minDiff) {\r\n      minDiff = diff;\r\n      bottomLeft = point;\r\n    }\r\n  }\r\n\r\n  return {\r\n    topLeft,\r\n    topRight,\r\n    bottomRight,\r\n    bottomLeft\r\n  };\r\n}\r\n\r\n/**\r\n * Orders 4 points in clockwise order starting from top-left\r\n * @param {Array} points - Array of 4 points to order\r\n * @returns {Object} Object with ordered points\r\n */\r\nfunction orderCornerPoints(points) {\r\n  if (points.length !== 4) {\r\n    console.warn(`Expected 4 points, got ${points.length}`);\r\n    return null;\r\n  }\r\n  \r\n  // Calculate centroid\r\n  const center = findCenter(points);\r\n  \r\n  // Sort the points by their angles relative to the center\r\n  const sortedPoints = [...points].sort((a, b) => {\r\n    const angleA = Math.atan2(a.y - center.y, a.x - center.x);\r\n    const angleB = Math.atan2(b.y - center.y, b.x - center.x);\r\n    return angleA - angleB;\r\n  });\r\n  \r\n  // Now find the top-left point (minimum sum of x and y)\r\n  let minSum = Infinity;\r\n  let minIndex = 0;\r\n  \r\n  for (let i = 0; i < 4; i++) {\r\n    const sum = sortedPoints[i].x + sortedPoints[i].y;\r\n    if (sum < minSum) {\r\n      minSum = sum;\r\n      minIndex = i;\r\n    }\r\n  }\r\n  \r\n  // Reorder array to start with the top-left point\r\n  const orderedPoints = [\r\n    sortedPoints[minIndex],\r\n    sortedPoints[(minIndex + 1) % 4],\r\n    sortedPoints[(minIndex + 2) % 4],\r\n    sortedPoints[(minIndex + 3) % 4]\r\n  ];\r\n  \r\n  // Return as named corners\r\n  return {\r\n    topLeft: orderedPoints[0],\r\n    topRight: orderedPoints[1],\r\n    bottomRight: orderedPoints[2],\r\n    bottomLeft: orderedPoints[3]\r\n  };\r\n}","let wasm;\n\nlet cachedFloat32ArrayMemory0 = null;\n\nfunction getFloat32ArrayMemory0() {\n    if (cachedFloat32ArrayMemory0 === null || cachedFloat32ArrayMemory0.byteLength === 0) {\n        cachedFloat32ArrayMemory0 = new Float32Array(wasm.memory.buffer);\n    }\n    return cachedFloat32ArrayMemory0;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArrayF32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\n    getFloat32ArrayMemory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction getArrayF32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getFloat32ArrayMemory0().subarray(ptr / 4, ptr / 4 + len);\n}\n/**\n * Find the best quadrilateral from detected lines\n * Returns: [tl_x, tl_y, tr_x, tr_y, br_x, br_y, bl_x, bl_y, confidence]\n * @param {Float32Array} lines\n * @param {number} width\n * @param {number} height\n * @param {number} min_area_ratio\n * @param {number} max_area_ratio\n * @returns {Float32Array}\n */\nexport function find_document_quadrilateral(lines, width, height, min_area_ratio, max_area_ratio) {\n    const ptr0 = passArrayF32ToWasm0(lines, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.find_document_quadrilateral(ptr0, len0, width, height, min_area_ratio, max_area_ratio);\n    var v2 = getArrayF32FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n    return v2;\n}\n\n/**\n * Find intersections between lines (for corner detection)\n * Input: array from hough_lines [rho0, theta0, votes0, ...]\n * Returns: [x0, y0, line1_idx, line2_idx, ...]\n * @param {Float32Array} lines\n * @param {number} width\n * @param {number} height\n * @param {number} min_angle_diff\n * @returns {Float32Array}\n */\nexport function find_line_intersections(lines, width, height, min_angle_diff) {\n    const ptr0 = passArrayF32ToWasm0(lines, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.find_line_intersections(ptr0, len0, width, height, min_angle_diff);\n    var v2 = getArrayF32FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n    return v2;\n}\n\nlet cachedUint8ArrayMemory0 = null;\n\nfunction getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1, 1) >>> 0;\n    getUint8ArrayMemory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n * Probabilistic Hough Line Transform (faster, returns line segments)\n * Returns flattened array: [x1_0, y1_0, x2_0, y2_0, votes0, ...]\n * @param {Uint8Array} edges\n * @param {number} width\n * @param {number} height\n * @param {number} rho_resolution\n * @param {number} theta_resolution\n * @param {number} threshold\n * @param {number} min_line_length\n * @param {number} max_line_gap\n * @param {number} max_lines\n * @returns {Float32Array}\n */\nexport function hough_lines_p(edges, width, height, rho_resolution, theta_resolution, threshold, min_line_length, max_line_gap, max_lines) {\n    const ptr0 = passArray8ToWasm0(edges, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.hough_lines_p(ptr0, len0, width, height, rho_resolution, theta_resolution, threshold, min_line_length, max_line_gap, max_lines);\n    var v2 = getArrayF32FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n    return v2;\n}\n\n/**\n * Standard Hough Line Transform\n * Returns flattened array: [rho0, theta0, votes0, rho1, theta1, votes1, ...]\n * @param {Uint8Array} edges\n * @param {number} width\n * @param {number} height\n * @param {number} rho_resolution\n * @param {number} theta_resolution\n * @param {number} threshold\n * @param {number} max_lines\n * @returns {Float32Array}\n */\nexport function hough_lines(edges, width, height, rho_resolution, theta_resolution, threshold, max_lines) {\n    const ptr0 = passArray8ToWasm0(edges, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.hough_lines(ptr0, len0, width, height, rho_resolution, theta_resolution, threshold, max_lines);\n    var v2 = getArrayF32FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n    return v2;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);\n}\n/**\n * Morphological opening (erosion followed by dilation)\n * Removes small bright spots (noise) while preserving shape\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} kernel_size\n * @param {number} element_type\n * @returns {Uint8Array}\n */\nexport function morphological_open(input, width, height, kernel_size, element_type) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.morphological_open(ptr0, len0, width, height, kernel_size, element_type);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Top-hat transform (original - opening)\n * Extracts bright features smaller than the structuring element\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} kernel_size\n * @param {number} element_type\n * @returns {Uint8Array}\n */\nexport function top_hat(input, width, height, kernel_size, element_type) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.top_hat(ptr0, len0, width, height, kernel_size, element_type);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Hit-or-miss transform for detecting specific patterns\n * Useful for finding corners and line endpoints\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {Uint8Array} hit_element\n * @param {Uint8Array} miss_element\n * @param {number} elem_size\n * @returns {Uint8Array}\n */\nexport function hit_or_miss(input, width, height, hit_element, miss_element, elem_size) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ptr1 = passArray8ToWasm0(hit_element, wasm.__wbindgen_malloc);\n    const len1 = WASM_VECTOR_LEN;\n    const ptr2 = passArray8ToWasm0(miss_element, wasm.__wbindgen_malloc);\n    const len2 = WASM_VECTOR_LEN;\n    const ret = wasm.hit_or_miss(ptr0, len0, width, height, ptr1, len1, ptr2, len2, elem_size);\n    var v4 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v4;\n}\n\n/**\n * Close gaps in edge lines\n * Specialized for document edge enhancement\n * @param {Uint8Array} edges\n * @param {number} width\n * @param {number} height\n * @param {number} gap_size\n * @returns {Uint8Array}\n */\nexport function close_edge_gaps(edges, width, height, gap_size) {\n    const ptr0 = passArray8ToWasm0(edges, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.close_edge_gaps(ptr0, len0, width, height, gap_size);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Morphological closing (dilation followed by erosion)\n * Fills small dark holes while preserving shape\n * Excellent for closing gaps in document edges\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} kernel_size\n * @param {number} element_type\n * @returns {Uint8Array}\n */\nexport function morphological_close(input, width, height, kernel_size, element_type) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.morphological_close(ptr0, len0, width, height, kernel_size, element_type);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Remove small connected components (noise)\n * Keeps only components larger than min_area\n * @param {Uint8Array} binary\n * @param {number} width\n * @param {number} height\n * @param {number} min_area\n * @returns {Uint8Array}\n */\nexport function remove_small_components(binary, width, height, min_area) {\n    const ptr0 = passArray8ToWasm0(binary, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.remove_small_components(ptr0, len0, width, height, min_area);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Morphological gradient (dilation - erosion)\n * Highlights edges\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} kernel_size\n * @param {number} element_type\n * @returns {Uint8Array}\n */\nexport function morphological_gradient(input, width, height, kernel_size, element_type) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.morphological_gradient(ptr0, len0, width, height, kernel_size, element_type);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Thin edges to single pixel width\n * Uses Zhang-Suen thinning algorithm\n * @param {Uint8Array} binary\n * @param {number} width\n * @param {number} height\n * @returns {Uint8Array}\n */\nexport function thin_edges(binary, width, height) {\n    const ptr0 = passArray8ToWasm0(binary, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.thin_edges(ptr0, len0, width, height);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Black-hat transform (closing - original)\n * Extracts dark features smaller than the structuring element\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} kernel_size\n * @param {number} element_type\n * @returns {Uint8Array}\n */\nexport function black_hat(input, width, height, kernel_size, element_type) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.black_hat(ptr0, len0, width, height, kernel_size, element_type);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Erosion operation\n * Each pixel becomes the minimum of its neighborhood defined by the structuring element\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} kernel_size\n * @param {number} element_type\n * @returns {Uint8Array}\n */\nexport function erode(input, width, height, kernel_size, element_type) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.erode(ptr0, len0, width, height, kernel_size, element_type);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Skeletonization using morphological operations\n * Useful for finding the central line of thick edges\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} max_iterations\n * @returns {Uint8Array}\n */\nexport function skeletonize(input, width, height, max_iterations) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.skeletonize(ptr0, len0, width, height, max_iterations);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Dilation operation (enhanced version of existing)\n * Each pixel becomes the maximum of its neighborhood\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} kernel_size\n * @param {number} element_type\n * @returns {Uint8Array}\n */\nexport function dilate_enhanced(input, width, height, kernel_size, element_type) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.dilate_enhanced(ptr0, len0, width, height, kernel_size, element_type);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Niblack's adaptive thresholding\n * T(x,y) = mean(x,y) + k * stddev(x,y)\n * k is typically -0.2 for document images\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} block_size\n * @param {number} k\n * @returns {Uint8Array}\n */\nexport function adaptive_threshold_niblack(input, width, height, block_size, k) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.adaptive_threshold_niblack(ptr0, len0, width, height, block_size, k);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Sauvola's adaptive thresholding - excellent for document images\n * T(x,y) = mean(x,y) * (1 + k * (stddev(x,y) / R - 1))\n * where R is the dynamic range of standard deviation (128 for 8-bit images)\n * k is typically 0.5 for document images\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} block_size\n * @param {number} k\n * @param {number} r\n * @returns {Uint8Array}\n */\nexport function adaptive_threshold_sauvola(input, width, height, block_size, k, r) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.adaptive_threshold_sauvola(ptr0, len0, width, height, block_size, k, r);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Adaptive Gaussian-weighted mean thresholding (similar to OpenCV's ADAPTIVE_THRESH_GAUSSIAN_C)\n * Weights decrease with distance from center pixel\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} block_size\n * @param {number} c\n * @returns {Uint8Array}\n */\nexport function adaptive_threshold_gaussian(input, width, height, block_size, c) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.adaptive_threshold_gaussian(ptr0, len0, width, height, block_size, c);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\nlet cachedUint32ArrayMemory0 = null;\n\nfunction getUint32ArrayMemory0() {\n    if (cachedUint32ArrayMemory0 === null || cachedUint32ArrayMemory0.byteLength === 0) {\n        cachedUint32ArrayMemory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachedUint32ArrayMemory0;\n}\n\nfunction getArrayU32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint32ArrayMemory0().subarray(ptr / 4, ptr / 4 + len);\n}\n/**\n * Adaptive thresholding methods\n * These automatically determine thresholds based on local image statistics,\n * which is crucial for documents with uneven lighting.\n * Calculate integral image for efficient local statistics computation\n * This allows O(1) computation of any rectangular sum\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @returns {Uint32Array}\n */\nexport function compute_integral_image(input, width, height) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.compute_integral_image(ptr0, len0, width, height);\n    var v2 = getArrayU32FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n    return v2;\n}\n\n/**\n * Adaptive mean thresholding (similar to OpenCV's ADAPTIVE_THRESH_MEAN_C)\n * For each pixel, threshold is the mean of block_size x block_size neighborhood minus C\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} block_size\n * @param {number} c\n * @returns {Uint8Array}\n */\nexport function adaptive_threshold_mean(input, width, height, block_size, c) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.adaptive_threshold_mean(ptr0, len0, width, height, block_size, c);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Multi-level Otsu thresholding for images with multiple intensity regions\n * Returns multiple thresholds for separating different regions\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} levels\n * @returns {Uint8Array}\n */\nexport function multi_otsu_threshold(input, width, height, levels) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.multi_otsu_threshold(ptr0, len0, width, height, levels);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Compute adaptive Canny thresholds based on image statistics\n * Returns (low_threshold, high_threshold) computed from gradient magnitude histogram\n * @param {Float32Array} magnitude\n * @param {number} width\n * @param {number} height\n * @param {number} low_ratio\n * @param {number} high_ratio\n * @returns {Float32Array}\n */\nexport function compute_adaptive_canny_thresholds(magnitude, width, height, low_ratio, high_ratio) {\n    const ptr0 = passArrayF32ToWasm0(magnitude, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.compute_adaptive_canny_thresholds(ptr0, len0, width, height, low_ratio, high_ratio);\n    var v2 = getArrayF32FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n    return v2;\n}\n\n/**\n * Otsu's method for automatic threshold selection\n * Returns the optimal threshold that minimizes intra-class variance\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @returns {number}\n */\nexport function otsu_threshold(input, width, height) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.otsu_threshold(ptr0, len0, width, height);\n    return ret;\n}\n\n/**\n * CLAHE - Contrast Limited Adaptive Histogram Equalization\n *\n * Parameters:\n * - input: grayscale image\n * - width, height: image dimensions\n * - tile_grid_x, tile_grid_y: number of tiles in x and y directions (typically 8x8)\n * - clip_limit: contrast limit (1.0 = no clipping, 2.0-4.0 typical for documents)\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} tile_grid_x\n * @param {number} tile_grid_y\n * @param {number} clip_limit\n * @returns {Uint8Array}\n */\nexport function clahe(input, width, height, tile_grid_x, tile_grid_y, clip_limit) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.clahe(ptr0, len0, width, height, tile_grid_x, tile_grid_y, clip_limit);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Simple contrast stretch (normalization)\n * Stretches histogram to use full 0-255 range\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @returns {Uint8Array}\n */\nexport function contrast_stretch(input, width, height) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.contrast_stretch(ptr0, len0, width, height);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Standard histogram equalization (global)\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @returns {Uint8Array}\n */\nexport function histogram_equalization(input, width, height) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.histogram_equalization(ptr0, len0, width, height);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Gamma correction for adjusting overall brightness\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} gamma\n * @returns {Uint8Array}\n */\nexport function gamma_correction(input, width, height, gamma) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.gamma_correction(ptr0, len0, width, height, gamma);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Illumination normalization using large-scale Gaussian\n * Removes low-frequency illumination variations\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} sigma\n * @returns {Uint8Array}\n */\nexport function illumination_normalize(input, width, height, sigma) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.illumination_normalize(ptr0, len0, width, height, sigma);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Combined preprocessing for document images\n * Applies: illumination normalization -> CLAHE -> contrast stretch\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} clahe_clip\n * @param {number} clahe_grid\n * @returns {Uint8Array}\n */\nexport function preprocess_document(input, width, height, clahe_clip, clahe_grid) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.preprocess_document(ptr0, len0, width, height, clahe_clip, clahe_grid);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Percentile-based contrast stretch\n * More robust to outliers than simple min-max stretch\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @param {number} low_percentile\n * @param {number} high_percentile\n * @returns {Uint8Array}\n */\nexport function percentile_contrast_stretch(input, width, height, low_percentile, high_percentile) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.percentile_contrast_stretch(ptr0, len0, width, height, low_percentile, high_percentile);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * @param {Uint8Array} grayscale\n * @param {number} width\n * @param {number} height\n * @param {number} kernel_size\n * @param {number} sigma\n * @returns {Uint8Array}\n */\nexport function blur(grayscale, width, height, kernel_size, sigma) {\n    const ptr0 = passArray8ToWasm0(grayscale, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.blur(ptr0, len0, width, height, kernel_size, sigma);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\nlet cachedUint16ArrayMemory0 = null;\n\nfunction getUint16ArrayMemory0() {\n    if (cachedUint16ArrayMemory0 === null || cachedUint16ArrayMemory0.byteLength === 0) {\n        cachedUint16ArrayMemory0 = new Uint16Array(wasm.memory.buffer);\n    }\n    return cachedUint16ArrayMemory0;\n}\n\nfunction passArray16ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 2, 2) >>> 0;\n    getUint16ArrayMemory0().set(arg, ptr / 2);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n * Refine corner positions using sub-pixel edge fitting\n * Uses gradient information to find precise edge locations\n * @param {Int16Array} gradients\n * @param {number} width\n * @param {number} height\n * @param {Float32Array} corners\n * @param {number} search_radius\n * @returns {Float32Array}\n */\nexport function refine_corners_subpixel(gradients, width, height, corners, search_radius) {\n    const ptr0 = passArray16ToWasm0(gradients, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ptr1 = passArrayF32ToWasm0(corners, wasm.__wbindgen_malloc);\n    const len1 = WASM_VECTOR_LEN;\n    const ret = wasm.refine_corners_subpixel(ptr0, len0, width, height, ptr1, len1, search_radius);\n    var v3 = getArrayF32FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n    return v3;\n}\n\n/**\n * Calculate size appropriateness score\n * Documents should occupy a reasonable portion of the frame\n * @param {Float32Array} corners\n * @param {number} image_width\n * @param {number} image_height\n * @param {number} min_coverage\n * @param {number} max_coverage\n * @param {number} ideal_coverage\n * @returns {number}\n */\nexport function calculate_size_score(corners, image_width, image_height, min_coverage, max_coverage, ideal_coverage) {\n    const ptr0 = passArrayF32ToWasm0(corners, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.calculate_size_score(ptr0, len0, image_width, image_height, min_coverage, max_coverage, ideal_coverage);\n    return ret;\n}\n\n/**\n * Validate corners represent a valid quadrilateral\n * @param {Float32Array} corners\n * @returns {Float32Array}\n */\nexport function validate_quadrilateral(corners) {\n    const ptr0 = passArrayF32ToWasm0(corners, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.validate_quadrilateral(ptr0, len0);\n    var v2 = getArrayF32FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n    return v2;\n}\n\n/**\n * Calculate overall document detection confidence\n * @param {number} edge_score\n * @param {number} shape_score\n * @param {number} aspect_score\n * @param {number} size_score\n * @returns {number}\n */\nexport function calculate_detection_confidence(edge_score, shape_score, aspect_score, size_score) {\n    const ret = wasm.calculate_detection_confidence(edge_score, shape_score, aspect_score, size_score);\n    return ret;\n}\n\n/**\n * Rank multiple document candidates and return the best ones\n * Input: flat array [corners0..., confidence0, corners1..., confidence1, ...]\n * Output: sorted array with same format, best first\n * @param {Float32Array} candidates\n * @param {number} max_candidates\n * @param {number} min_confidence\n * @returns {Float32Array}\n */\nexport function rank_document_candidates(candidates, max_candidates, min_confidence) {\n    const ptr0 = passArrayF32ToWasm0(candidates, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.rank_document_candidates(ptr0, len0, max_candidates, min_confidence);\n    var v2 = getArrayF32FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n    return v2;\n}\n\n/**\n * Calculate edge strength along quadrilateral edges\n * Uses gradient magnitude along the detected edges\n * @param {Int16Array} gradients\n * @param {number} width\n * @param {number} height\n * @param {Float32Array} corners\n * @param {number} sample_points\n * @returns {number}\n */\nexport function calculate_edge_strength(gradients, width, height, corners, sample_points) {\n    const ptr0 = passArray16ToWasm0(gradients, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ptr1 = passArrayF32ToWasm0(corners, wasm.__wbindgen_malloc);\n    const len1 = WASM_VECTOR_LEN;\n    const ret = wasm.calculate_edge_strength(ptr0, len0, width, height, ptr1, len1, sample_points);\n    return ret;\n}\n\nlet cachedInt16ArrayMemory0 = null;\n\nfunction getInt16ArrayMemory0() {\n    if (cachedInt16ArrayMemory0 === null || cachedInt16ArrayMemory0.byteLength === 0) {\n        cachedInt16ArrayMemory0 = new Int16Array(wasm.memory.buffer);\n    }\n    return cachedInt16ArrayMemory0;\n}\n\nfunction getArrayI16FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getInt16ArrayMemory0().subarray(ptr / 2, ptr / 2 + len);\n}\n/**\n * @param {Uint8Array} blurred\n * @param {number} width\n * @param {number} height\n * @returns {Int16Array}\n */\nexport function calculate_gradients(blurred, width, height) {\n    const ptr0 = passArray8ToWasm0(blurred, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.calculate_gradients(ptr0, len0, width, height);\n    var v2 = getArrayI16FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 2, 2);\n    return v2;\n}\n\n/**\n * @param {Int16Array} dx\n * @param {Int16Array} dy\n * @param {number} width\n * @param {number} height\n * @param {boolean} l2_gradient\n * @returns {Float32Array}\n */\nexport function non_maximum_suppression(dx, dy, width, height, l2_gradient) {\n    const ptr0 = passArray16ToWasm0(dx, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ptr1 = passArray16ToWasm0(dy, wasm.__wbindgen_malloc);\n    const len1 = WASM_VECTOR_LEN;\n    const ret = wasm.non_maximum_suppression(ptr0, len0, ptr1, len1, width, height, l2_gradient);\n    var v3 = getArrayF32FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n    return v3;\n}\n\n/**\n * @param {Uint8Array} edges\n * @param {number} width\n * @param {number} height\n * @param {number} kernel_size\n * @returns {Uint8Array}\n */\nexport function dilate(edges, width, height, kernel_size) {\n    const ptr0 = passArray8ToWasm0(edges, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.dilate(ptr0, len0, width, height, kernel_size);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Enhanced non-maximum suppression using precise gradient direction\n * This provides better edge localization than the binned direction approach\n * @param {Float32Array} magnitude\n * @param {Float32Array} direction\n * @param {number} width\n * @param {number} height\n * @returns {Float32Array}\n */\nexport function nms_precise(magnitude, direction, width, height) {\n    const ptr0 = passArrayF32ToWasm0(magnitude, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ptr1 = passArrayF32ToWasm0(direction, wasm.__wbindgen_malloc);\n    const len1 = WASM_VECTOR_LEN;\n    const ret = wasm.nms_precise(ptr0, len0, ptr1, len1, width, height);\n    var v3 = getArrayF32FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n    return v3;\n}\n\n/**\n * Calculate Sobel gradients using 3x3 kernel\n * Returns interleaved [gx0, gy0, gx1, gy1, ...] as i16 values\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @returns {Int16Array}\n */\nexport function sobel_gradients_3x3(input, width, height) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.sobel_gradients_3x3(ptr0, len0, width, height);\n    var v2 = getArrayI16FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 2, 2);\n    return v2;\n}\n\n/**\n * Calculate Sobel gradients with SIMD optimization\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @returns {Int16Array}\n */\nexport function sobel_gradients_3x3_simd(input, width, height) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.sobel_gradients_3x3_simd(ptr0, len0, width, height);\n    var v2 = getArrayI16FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 2, 2);\n    return v2;\n}\n\n/**\n * Compute edge direction map for document detection\n * Returns direction in degrees [0, 180) for each pixel\n * @param {Int16Array} gradients\n * @param {number} width\n * @param {number} height\n * @returns {Uint8Array}\n */\nexport function edge_direction_map(gradients, width, height) {\n    const ptr0 = passArray16ToWasm0(gradients, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.edge_direction_map(ptr0, len0, width, height);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Calculate Sobel 5x5 gradients for more robust edge detection\n * Larger kernel provides better noise immunity but slightly more blur\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @returns {Int16Array}\n */\nexport function sobel_gradients_5x5(input, width, height) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.sobel_gradients_5x5(ptr0, len0, width, height);\n    var v2 = getArrayI16FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 2, 2);\n    return v2;\n}\n\n/**\n * Compute gradient magnitude and direction\n * Returns: [magnitude_0, direction_0, magnitude_1, direction_1, ...]\n * Direction is quantized to 0-7 representing 8 directions (0, 22.5, 45, ... 157.5)\n * @param {Int16Array} gradients\n * @param {number} width\n * @param {number} height\n * @param {boolean} l2_norm\n * @returns {Float32Array}\n */\nexport function gradient_magnitude_direction(gradients, width, height, l2_norm) {\n    const ptr0 = passArray16ToWasm0(gradients, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.gradient_magnitude_direction(ptr0, len0, width, height, l2_norm);\n    var v2 = getArrayF32FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n    return v2;\n}\n\n/**\n * Calculate Scharr gradients using 3x3 kernel (better accuracy than Sobel)\n * Returns interleaved [gx0, gy0, gx1, gy1, ...] as i16 values\n * @param {Uint8Array} input\n * @param {number} width\n * @param {number} height\n * @returns {Int16Array}\n */\nexport function scharr_gradients_3x3(input, width, height) {\n    const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.scharr_gradients_3x3(ptr0, len0, width, height);\n    var v2 = getArrayI16FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 2, 2);\n    return v2;\n}\n\n/**\n * Applies double thresholding and hysteresis using a stack-based approach.\n * Optimized version with SIMD for threshold comparisons and better memory access patterns.\n * Follows OpenCV's logic more closely.\n *\n * # Arguments\n * * `suppressed` - Suppressed magnitude values (Float32Array from JavaScript)\n * * `width` - Image width\n * * `height` - Image height\n * * `low_threshold` - Low threshold value\n * * `high_threshold` - High threshold value\n *\n * # Returns\n * Edge map as Vec<u8> (0: weak edge/potential, 1: non-edge, 2: strong edge)\n * @param {Float32Array} suppressed\n * @param {number} width\n * @param {number} height\n * @param {number} low_threshold\n * @param {number} high_threshold\n * @returns {Uint8Array}\n */\nexport function hysteresis_thresholding(suppressed, width, height, low_threshold, high_threshold) {\n    const ptr0 = passArrayF32ToWasm0(suppressed, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.hysteresis_thresholding(ptr0, len0, width, height, low_threshold, high_threshold);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Combined hysteresis thresholding and binary conversion\n * This is a convenience function that combines both steps for efficiency\n * Optimized to avoid intermediate allocations where possible\n *\n * # Arguments\n * * `suppressed` - Suppressed magnitude values (Float32Array from JavaScript)\n * * `width` - Image width\n * * `height` - Image height\n * * `low_threshold` - Low threshold value\n * * `high_threshold` - High threshold value\n *\n * # Returns\n * Binary edge image as Vec<u8> (0 or 255)\n * @param {Float32Array} suppressed\n * @param {number} width\n * @param {number} height\n * @param {number} low_threshold\n * @param {number} high_threshold\n * @returns {Uint8Array}\n */\nexport function hysteresis_thresholding_binary(suppressed, width, height, low_threshold, high_threshold) {\n    const ptr0 = passArrayF32ToWasm0(suppressed, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.hysteresis_thresholding_binary(ptr0, len0, width, height, low_threshold, high_threshold);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Creates a binary edge image from the hysteresis edge map\n * SIMD-optimized version for converting edge map to binary\n *\n * # Arguments\n * * `edge_map` - Edge map from hysteresis thresholding (0, 1, 2 values)\n *\n * # Returns\n * Binary edge image as Vec<u8> (0 or 255)\n * @param {Uint8Array} edge_map\n * @returns {Uint8Array}\n */\nexport function edge_map_to_binary(edge_map) {\n    const ptr0 = passArray8ToWasm0(edge_map, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.edge_map_to_binary(ptr0, len0);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * @param {Uint8Array} grayscale\n * @param {number} width\n * @param {number} height\n * @param {number} low_threshold\n * @param {number} high_threshold\n * @param {number} kernel_size\n * @param {number} sigma\n * @param {boolean} l2_gradient\n * @param {boolean} apply_dilation\n * @param {number} dilation_kernel_size\n * @returns {Uint8Array}\n */\nexport function canny_edge_detector_full(grayscale, width, height, low_threshold, high_threshold, kernel_size, sigma, l2_gradient, apply_dilation, dilation_kernel_size) {\n    const ptr0 = passArray8ToWasm0(grayscale, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.canny_edge_detector_full(ptr0, len0, width, height, low_threshold, high_threshold, kernel_size, sigma, l2_gradient, apply_dilation, dilation_kernel_size);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbindgen_init_externref_table = function() {\n        const table = wasm.__wbindgen_export_0;\n        const offset = table.grow(4);\n        table.set(0, undefined);\n        table.set(offset + 0, undefined);\n        table.set(offset + 1, null);\n        table.set(offset + 2, true);\n        table.set(offset + 3, false);\n        ;\n    };\n\n    return imports;\n}\n\nfunction __wbg_init_memory(imports, memory) {\n\n}\n\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedFloat32ArrayMemory0 = null;\n    cachedInt16ArrayMemory0 = null;\n    cachedUint16ArrayMemory0 = null;\n    cachedUint32ArrayMemory0 = null;\n    cachedUint8ArrayMemory0 = null;\n\n\n    wasm.__wbindgen_start();\n    return wasm;\n}\n\nfunction initSync(module) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module !== 'undefined') {\n        if (Object.getPrototypeOf(module) === Object.prototype) {\n            ({module} = module)\n        } else {\n            console.warn('using deprecated parameters for `initSync()`; pass a single object instead')\n        }\n    }\n\n    const imports = __wbg_get_imports();\n\n    __wbg_init_memory(imports);\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(module_or_path) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module_or_path !== 'undefined') {\n        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n            ({module_or_path} = module_or_path)\n        } else {\n            console.warn('using deprecated parameters for the initialization function; pass a single object instead')\n        }\n    }\n\n    if (typeof module_or_path === 'undefined') {\n        module_or_path = new URL('wasm_blur_bg.wasm', import.meta.url);\n    }\n    const imports = __wbg_get_imports();\n\n    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {\n        module_or_path = fetch(module_or_path);\n    }\n\n    __wbg_init_memory(imports);\n\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nexport { initSync };\nexport default __wbg_init;\n","/**\r\n * Pure JavaScript implementation of edge detection algorithms\r\n * Inspired by OpenCV's Canny edge detector\r\n */\r\n\r\nimport { DEFAULTS } from './constants.js';\r\nimport init, { \r\n  blur as wasmBlur, \r\n  calculate_gradients as wasmGradients, \r\n  dilate as wasmDilate, \r\n  non_maximum_suppression as wasmMaximumSuppression, \r\n  canny_edge_detector_full as wasmFullCanny,\r\n  hysteresis_thresholding as wasmHysteresis,\r\n  hysteresis_thresholding_binary as wasmHysteresisBinary\r\n} from '../wasm_blur/pkg/wasm_blur.js';\r\n\r\n// Initialize the wasm module\r\nconst wasmReady = init();\r\n\r\n/**\r\n * Converts ImageData to grayscale (separate from blur for consistency with jscanify)\r\n * @param {ImageData} imageData - Original image data\r\n * @returns {Uint8ClampedArray} Grayscale image data (1 channel)\r\n */\r\nexport function convertToGrayscale(imageData) {\r\n  const { width, height, data } = imageData;\r\n  const grayscale = new Uint8ClampedArray(width * height);\r\n  \r\n  // Convert to grayscale with integer math (faster than floating point)\r\n  // Use bit shifting for multiplication (>>8 is equivalent to /256)\r\n  for (let i = 0, j = 0; i < data.length; i += 4, j++) {\r\n    // 54 (~0.2126*256), 183 (~0.7152*256), 19 (~0.0722*256)\r\n    grayscale[j] = (data[i] * 54 + data[i+1] * 183 + data[i+2] * 19) >> 8;\r\n  }\r\n  \r\n  return grayscale;\r\n}\r\n\r\n/**\r\n * Applies Gaussian blur to a grayscale image (matching jscanify's approach)\r\n * @param {Uint8ClampedArray} grayscale - Grayscale image data\r\n * @param {number} width - Image width\r\n * @param {number} height - Image height\r\n * @param {number} kernelSize - Kernel size (should be 5 to match jscanify)\r\n * @param {number} sigma - Gaussian sigma parameter\r\n * @returns {Uint8ClampedArray} Blurred grayscale image data\r\n */\r\nexport function gaussianBlurGrayscale(grayscale, width, height, kernelSize = 5, sigma = 0) {\r\n  // If sigma is 0, calculate it from kernel size (OpenCV default)\r\n  if (sigma === 0) {\r\n    sigma = 0.3 * ((kernelSize - 1) * 0.5 - 1) + 0.8;\r\n  }\r\n  \r\n  const halfKernel = Math.floor(kernelSize / 2);\r\n  \r\n  // Create and normalize Gaussian kernel once\r\n  const kernel = createGaussianKernel(kernelSize, sigma);\r\n  \r\n  // Preallocate arrays\r\n  const tempArray = new Uint8ClampedArray(width * height);\r\n  const blurred = new Uint8ClampedArray(width * height);\r\n  \r\n  // Horizontal pass - process rows in a single loop to improve cache locality\r\n  for (let y = 0; y < height; y++) {\r\n    const rowOffset = y * width;\r\n    \r\n    for (let x = 0; x < width; x++) {\r\n      let sum = 0;\r\n      \r\n      // Apply kernel horizontally with bounds checking\r\n      for (let k = -halfKernel; k <= halfKernel; k++) {\r\n        const xOffset = Math.min(width - 1, Math.max(0, x + k));\r\n        sum += grayscale[rowOffset + xOffset] * kernel[halfKernel + k];\r\n      }\r\n      \r\n      tempArray[rowOffset + x] = sum;\r\n    }\r\n  }\r\n  \r\n  // Vertical pass - process columns with better memory access pattern\r\n  for (let x = 0; x < width; x++) {\r\n    for (let y = 0; y < height; y++) {\r\n      let sum = 0;\r\n      \r\n      // Apply kernel vertically with bounds checking\r\n      for (let k = -halfKernel; k <= halfKernel; k++) {\r\n        const yOffset = Math.min(height - 1, Math.max(0, y + k));\r\n        sum += tempArray[yOffset * width + x] * kernel[halfKernel + k];\r\n      }\r\n      \r\n      blurred[y * width + x] = Math.round(sum);\r\n    }\r\n  }\r\n  \r\n  return blurred;\r\n}\r\n\r\n/**\r\n * Legacy wrapper for backwards compatibility\r\n * @param {ImageData} imageData - Original image data\r\n * @param {number} sigma - Gaussian sigma parameter (standard deviation)\r\n * @returns {Uint8ClampedArray} Blurred grayscale image data (1 channel)\r\n */\r\nexport function gaussianBlur(imageData, sigma = DEFAULTS.GAUSSIAN_SIGMA, forcedKernelSize = null) {\r\n  const grayscale = convertToGrayscale(imageData);\r\n  const kernelSize = forcedKernelSize || 5; // Default to 5 like jscanify\r\n  return gaussianBlurGrayscale(grayscale, imageData.width, imageData.height, kernelSize, sigma);\r\n}\r\n\r\n/**\r\n * Creates a 1D Gaussian kernel\r\n * @param {number} size - Kernel size (odd number)\r\n * @param {number} sigma - Gaussian sigma parameter\r\n * @returns {Float32Array} Gaussian kernel\r\n */\r\nfunction createGaussianKernel(size, sigma) {\r\n  const kernel = new Float32Array(size);\r\n  const halfSize = Math.floor(size / 2);\r\n  \r\n  let sum = 0;\r\n  for (let i = 0; i < size; i++) {\r\n    const x = i - halfSize;\r\n    // Gaussian function: (1/(sigma*sqrt(2*PI))) * e^(-(x^2)/(2*sigma^2))\r\n    kernel[i] = Math.exp(-(x * x) / (2 * sigma * sigma));\r\n    sum += kernel[i];\r\n  }\r\n  \r\n  // Normalize kernel\r\n  for (let i = 0; i < size; i++) {\r\n    kernel[i] /= sum;\r\n  }\r\n  \r\n  return kernel;\r\n}\r\n\r\n/**\r\n * Calculates the gradients (dx, dy) using Sobel operators\r\n * @param {Uint8ClampedArray} blurred - Blurred grayscale image\r\n * @param {number} width - Image width\r\n * @param {number} height - Image height\r\n * @returns {{dx: Int16Array, dy: Int16Array}} Object containing gradient arrays\r\n */\r\nfunction calculateGradients(blurred, width, height) {\r\n  // Use Int16Array to store gradients, allowing negative values\r\n  const dx = new Int16Array(width * height);\r\n  const dy = new Int16Array(width * height);\r\n  \r\n  // Find gradients by unrolling the Sobel operator loops\r\n  for (let y = 1; y < height - 1; y++) {\r\n    const rowOffset = y * width;\r\n    const prevRowOffset = (y - 1) * width;\r\n    const nextRowOffset = (y + 1) * width;\r\n\r\n    for (let x = 1; x < width - 1; x++) {\r\n      const currentIdx = rowOffset + x;\r\n\r\n      // Get neighborhood pixels\r\n      const p0 = blurred[prevRowOffset + x - 1];\r\n      const p1 = blurred[prevRowOffset + x];\r\n      const p2 = blurred[prevRowOffset + x + 1];\r\n      const p3 = blurred[rowOffset + x - 1];\r\n      const p5 = blurred[rowOffset + x + 1];\r\n      const p6 = blurred[nextRowOffset + x - 1];\r\n      const p7 = blurred[nextRowOffset + x];\r\n      const p8 = blurred[nextRowOffset + x + 1];\r\n      \r\n      // Calculate Sobel gradients\r\n      const gx = (p2 - p0) + 2 * (p5 - p3) + (p8 - p6);\r\n      const gy = (p6 + 2 * p7 + p8) - (p0 + 2 * p1 + p2);\r\n      \r\n      dx[currentIdx] = gx;\r\n      dy[currentIdx] = gy;\r\n    }\r\n  }\r\n  \r\n  return { dx, dy };\r\n}\r\n\r\n\r\n/**\r\n * Applies non-maximum suppression to the gradient magnitude\r\n * @param {Int16Array} dx - Gradient in x-direction\r\n * @param {Int16Array} dy - Gradient in y-direction\r\n * @param {number} width - Image width\r\n * @param {number} height - Image height\r\n * @param {boolean} L2gradient - Whether to use L2 norm for magnitude\r\n * @returns {Float32Array} Suppressed magnitude (using Float32 for precision)\r\n */\r\nfunction nonMaximumSuppression(dx, dy, width, height, L2gradient) {\r\n  // Use Float32Array for magnitude to preserve precision before thresholding\r\n  const magnitude = new Float32Array(width * height);\r\n  const suppressed = new Float32Array(width * height);\r\n  \r\n  // Calculate magnitude for all pixels first\r\n  for (let i = 0; i < dx.length; i++) {\r\n    const gx = dx[i];\r\n    const gy = dy[i];\r\n    if (L2gradient) {\r\n      magnitude[i] = Math.sqrt(gx * gx + gy * gy);\r\n    } else {\r\n      magnitude[i] = Math.abs(gx) + Math.abs(gy); // L1 norm\r\n    }\r\n  }\r\n  \r\n  // Perform non-maximum suppression\r\n  for (let y = 1; y < height - 1; y++) {\r\n    for (let x = 1; x < width - 1; x++) {\r\n      const idx = y * width + x;\r\n      const mag = magnitude[idx];\r\n      \r\n      // Skip pixels with zero magnitude\r\n      if (mag === 0) {\r\n        suppressed[idx] = 0;\r\n        continue;\r\n      }\r\n      \r\n      const gx = dx[idx];\r\n      const gy = dy[idx];\r\n      \r\n      let neighbor1 = 0, neighbor2 = 0;\r\n      \r\n      // Determine neighbors based on gradient direction\r\n      // Use absolute values to determine dominant direction\r\n      const absGx = Math.abs(gx);\r\n      const absGy = Math.abs(gy);\r\n      \r\n      if (absGy > absGx * 2.4142) { // Vertical edge (angle near 90 or 270)\r\n        neighbor1 = magnitude[idx - width]; // top\r\n        neighbor2 = magnitude[idx + width]; // bottom\r\n      } else if (absGx > absGy * 2.4142) { // Horizontal edge (angle near 0 or 180)\r\n        neighbor1 = magnitude[idx - 1]; // left\r\n        neighbor2 = magnitude[idx + 1]; // right\r\n      } else { // Diagonal edge\r\n        // Determine diagonal direction based on signs of gx and gy\r\n        const s = (gx ^ gy) < 0 ? -1 : 1; // Check if signs are different\r\n        if (gy > 0) { // Gradient points down\r\n          neighbor1 = magnitude[(y - 1) * width + (x - s)]; // top-left/right\r\n          neighbor2 = magnitude[(y + 1) * width + (x + s)]; // bottom-right/left\r\n        } else { // Gradient points up\r\n          neighbor1 = magnitude[(y + 1) * width + (x - s)]; // bottom-left/right\r\n          neighbor2 = magnitude[(y - 1) * width + (x + s)]; // top-right/left\r\n        }\r\n        // Refined diagonal check (approximating OpenCV's logic)\r\n        // Check 45 degrees (top-right / bottom-left)\r\n        if ((gx > 0 && gy > 0) || (gx < 0 && gy < 0)) { // Quadrants 1 & 3\r\n             neighbor1 = magnitude[(y - 1) * width + (x + 1)]; // top-right\r\n             neighbor2 = magnitude[(y + 1) * width + (x - 1)]; // bottom-left\r\n        } else { // Quadrants 2 & 4 (135 degrees)\r\n             neighbor1 = magnitude[(y - 1) * width + (x - 1)]; // top-left\r\n             neighbor2 = magnitude[(y + 1) * width + (x + 1)]; // bottom-right\r\n        }\r\n      }\r\n      \r\n      // If the pixel's magnitude is greater than or equal to its neighbors\r\n      // along the gradient direction, keep it. Otherwise, suppress it.\r\n      if (mag >= neighbor1 && mag >= neighbor2) {\r\n        suppressed[idx] = mag;\r\n      } else {\r\n        suppressed[idx] = 0;\r\n      }\r\n    }\r\n  }\r\n  return suppressed;\r\n}\r\n\r\n\r\n/**\r\n * Applies double thresholding and hysteresis using a stack-based approach.\r\n * Follows OpenCV's logic more closely.\r\n * @param {Float32Array} suppressed - Suppressed magnitude (Float32Array)\r\n * @param {number} width - Image width\r\n * @param {number} height - Image height\r\n * @param {number} lowThreshold - Low threshold value\r\n * @param {number} highThreshold - High threshold value\r\n * @returns {Uint8Array} Edge map (0: non-edge, 2: edge pixel)\r\n */\r\nfunction hysteresisThresholding(suppressed, width, height, lowThreshold, highThreshold) {\r\n  // Map values: 0 = weak edge (potential), 1 = non-edge, 2 = strong edge\r\n  const edgeMap = new Uint8Array(width * height);\r\n  const stack = [];\r\n  \r\n  // First pass: Identify strong edges and potential weak edges\r\n  for (let y = 1; y < height - 1; y++) { // Iterate excluding borders\r\n    for (let x = 1; x < width - 1; x++) {\r\n      const idx = y * width + x;\r\n      const mag = suppressed[idx];\r\n      \r\n      if (mag >= highThreshold) {\r\n        // Strong edge pixel\r\n        edgeMap[idx] = 2;\r\n        stack.push({ x, y });\r\n      } else if (mag >= lowThreshold) {\r\n        // Weak edge pixel (potential edge)\r\n        edgeMap[idx] = 0; // Mark as potential\r\n      } else {\r\n        // Non-edge pixel\r\n        edgeMap[idx] = 1; // Mark as non-edge\r\n      }\r\n    }\r\n  }\r\n  // Initialize borders as non-edge (value 1)\r\n   for (let x = 0; x < width; x++) {\r\n       edgeMap[x] = 1; // Top row\r\n       edgeMap[(height - 1) * width + x] = 1; // Bottom row\r\n   }\r\n   for (let y = 1; y < height - 1; y++) {\r\n       edgeMap[y * width] = 1; // Left column\r\n       edgeMap[y * width + width - 1] = 1; // Right column\r\n   }\r\n\r\n\r\n  // Second pass: Hysteresis - connect weak edges to strong edges\r\n  const dxNeighbors = [-1, 0, 1, -1, 1, -1, 0, 1];\r\n  const dyNeighbors = [-1, -1, -1, 0, 0, 1, 1, 1];\r\n  \r\n  while (stack.length > 0) {\r\n    const { x, y } = stack.pop();\r\n    \r\n    // Check all 8 neighbors\r\n    for (let i = 0; i < 8; i++) {\r\n      const nx = x + dxNeighbors[i];\r\n      const ny = y + dyNeighbors[i];\r\n      const nidx = ny * width + nx;\r\n      \r\n      // Check bounds (already handled by border initialization)\r\n      // If neighbor is a weak edge (value 0), promote it to strong (value 2) and add to stack\r\n      if (edgeMap[nidx] === 0) {\r\n        edgeMap[nidx] = 2; // Promote to strong edge\r\n        stack.push({ x: nx, y: ny });\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Note: Pixels that were initially weak (0) but not connected remain 0.\r\n  // Pixels below lowThreshold remain 1. Only pixels marked 2 are considered final edges.\r\n  \r\n  return edgeMap; // Return the map with 0, 1, 2 values\r\n}\r\n\r\n/**\r\n * Applies morphological dilation to binary image using a separable (two-pass) approach.\r\n * This is much faster than a 2D kernel for square structuring elements.\r\n * @param {Uint8ClampedArray} edges - Binary edge image (0 or 255)\r\n * @param {number} width - Image width\r\n * @param {number} height - Image height\r\n * @param {number} kernelSize - Kernel size (default 5 to match jscanify)\r\n * @returns {Uint8ClampedArray} Dilated edge image\r\n */\r\nexport function dilateEdges(edges, width, height, kernelSize = 5) {\r\n  const halfKernel = Math.floor(kernelSize / 2);\r\n  const temp = new Uint8ClampedArray(width * height);\r\n  const dilated = new Uint8ClampedArray(width * height);\r\n\r\n  // Horizontal pass\r\n  for (let y = 0; y < height; y++) {\r\n    const rowOffset = y * width;\r\n    for (let x = 0; x < width; x++) {\r\n      let maxVal = 0;\r\n      // Find max in horizontal neighborhood\r\n      for (let k = -halfKernel; k <= halfKernel; k++) {\r\n        const nx = x + k;\r\n        if (nx >= 0 && nx < width) {\r\n          const val = edges[rowOffset + nx];\r\n          if (val > maxVal) {\r\n            maxVal = val;\r\n          }\r\n        }\r\n      }\r\n      temp[rowOffset + x] = maxVal;\r\n    }\r\n  }\r\n\r\n  // Vertical pass\r\n  for (let x = 0; x < width; x++) {\r\n    for (let y = 0; y < height; y++) {\r\n      let maxVal = 0;\r\n      // Find max in vertical neighborhood from temp array\r\n      for (let k = -halfKernel; k <= halfKernel; k++) {\r\n        const ny = y + k;\r\n        if (ny >= 0 && ny < height) {\r\n          const val = temp[ny * width + x];\r\n          if (val > maxVal) {\r\n            maxVal = val;\r\n          }\r\n        }\r\n      }\r\n      dilated[y * width + x] = maxVal;\r\n    }\r\n  }\r\n  \r\n  return dilated;\r\n}\r\n\r\n/**\r\n * Full Canny edge detector implementation matching jscanify's approach\r\n * @param {ImageData} imageData - Original image data\r\n * @param {Object} options - Configuration options\r\n * @param {number} [options.lowThreshold=75] - Low threshold for hysteresis (matching jscanify)\r\n * @param {number} [options.highThreshold=200] - High threshold for hysteresis (matching jscanify)\r\n * @param {number} [options.sigma=0] - Gaussian blur sigma (0 means auto-calculate from kernel size)\r\n * @param {number} [options.kernelSize=5] - Gaussian kernel size (matching jscanify)\r\n * @param {boolean} [options.L2gradient=false] - Use L2 norm for gradient magnitude (like OpenCV default)\r\n * @param {boolean} [options.applyDilation=true] - Apply dilation after Canny (matching jscanify)\r\n * @param {number} [options.dilationKernelSize=5] - Dilation kernel size\r\n * @param {boolean} [options.useWasmBlur=false] - Use WASM for Gaussian blur\r\n * @param {boolean} [options.useWasmGradients=false] - Use WASM for gradient calculation\r\n * @param {boolean} [options.useWasmDilation=false] - Use WASM for dilation\r\n * @param {boolean} [options.useWasmNMS=false] - Use WASM for non-maximum suppression\r\n * @param {boolean} [options.useWasmHysteresis=false] - Use WASM for hysteresis thresholding\r\n * @param {boolean} [options.useWasmFullCanny=false] - Use the full WASM Canny implementation\r\n * @param {object} [options.debug={}] - Object to store intermediate results if provided\r\n * @returns {Promise<Uint8ClampedArray>} Binary edge image (0 or 255)\r\n */\r\nexport async function cannyEdgeDetector(imageData, options = {}) {\r\n  // Timing table setup\r\n  const timings = [];\r\n  const tStart = performance.now();\r\n\r\n  const { width, height } = imageData;\r\n  let lowThreshold = options.lowThreshold !== undefined ? options.lowThreshold : 75;\r\n  let highThreshold = options.highThreshold !== undefined ? options.highThreshold : 200;\r\n  const kernelSize = options.kernelSize || 5; // Match jscanify's 5x5 kernel\r\n  const sigma = options.sigma || 0; // Let the blur function calculate sigma\r\n  const L2gradient = options.L2gradient === undefined ? false : options.L2gradient;\r\n  const applyDilation = options.applyDilation !== undefined ? options.applyDilation : true;\r\n  const dilationKernelSize = options.dilationKernelSize || 5;\r\n  const useWasmBlur = true;\r\n  const useWasmGradients = false; \r\n  const useWasmDilation = true;\r\n  const useWasmNMS = true;\r\n  const useWasmHysteresis = options.useWasmHysteresis !== undefined ? options.useWasmHysteresis : false;\r\n  const useWasmFullCanny = false;\r\n\r\n  // Ensure high threshold is greater than low threshold\r\n  if (lowThreshold >= highThreshold) {\r\n      console.warn(`Canny Edge Detector: lowThreshold (${lowThreshold}) should be lower than highThreshold (${highThreshold}). Swapping them.`);\r\n      [lowThreshold, highThreshold] = [highThreshold, lowThreshold];\r\n  }\r\n\r\n  // Step 1: Convert to grayscale\r\n  let t0 = performance.now();\r\n  const grayscale = convertToGrayscale(imageData);\r\n  let t1 = performance.now();\r\n  timings.push({ step: 'Grayscale', ms: (t1 - t0).toFixed(2) });\r\n  if (options.debug) options.debug.grayscale = grayscale;\r\n\r\n  // Step 2: Apply Gaussian blur (JS or WASM)\r\n  let blurred;\r\n  t0 = performance.now();\r\n  if (useWasmBlur) {\r\n    try {\r\n      await wasmReady; // Ensure wasm is initialized\r\n      blurred = wasmBlur(grayscale, width, height, kernelSize, sigma);\r\n    } catch (e) {\r\n      blurred = gaussianBlurGrayscale(grayscale, width, height, kernelSize, sigma);\r\n    }\r\n  } else {\r\n    blurred = gaussianBlurGrayscale(grayscale, width, height, kernelSize, sigma);\r\n  }\r\n  t1 = performance.now();\r\n  timings.push({ step: 'Gaussian Blur', ms: (t1 - t0).toFixed(2) });\r\n  if (options.debug) {\r\n    options.debug.blurred = blurred;\r\n  }\r\n\r\n  // Step 3: Compute gradients (dx, dy)\r\n  t0 = performance.now();\r\n  let dx, dy;\r\n  if (useWasmGradients) {\r\n    try {\r\n      await wasmReady; // Ensure wasm is initialized\r\n      const gradientResult = wasmGradients(blurred, width, height);\r\n      dx = new Int16Array(gradientResult.gx);\r\n      dy = new Int16Array(gradientResult.gy);\r\n    } catch (e) {\r\n      const gradients = calculateGradients(blurred, width, height);\r\n      dx = gradients.dx;\r\n      dy = gradients.dy;\r\n    }\r\n  } else {\r\n    const gradients = calculateGradients(blurred, width, height);\r\n    dx = gradients.dx;\r\n    dy = gradients.dy;\r\n  }\r\n  t1 = performance.now();\r\n  timings.push({ step: 'Gradients', ms: (t1 - t0).toFixed(2) });\r\n\r\n  // Step 4: Apply non-maximum suppression\r\n  t0 = performance.now();\r\n  let suppressed;\r\n  if (useWasmNMS) {\r\n    try {\r\n      await wasmReady;\r\n      suppressed = await wasmMaximumSuppression(dx, dy, width, height, L2gradient);\r\n    } catch (e) {\r\n      suppressed = nonMaximumSuppression(dx, dy, width, height, L2gradient);\r\n    }\r\n  } else {\r\n    suppressed = nonMaximumSuppression(dx, dy, width, height, L2gradient);\r\n  }\r\n  t1 = performance.now();\r\n  timings.push({ step: 'Non-Max Suppression', ms: (t1 - t0).toFixed(2) });\r\n\r\n  // Step 5: Apply double thresholding and hysteresis\r\n  t0 = performance.now();\r\n  const finalLowThreshold = L2gradient ? lowThreshold * lowThreshold : lowThreshold;\r\n  const finalHighThreshold = L2gradient ? highThreshold * highThreshold : highThreshold;\r\n  \r\n  let edgeMap;\r\n  if (useWasmHysteresis) {\r\n    try {\r\n      await wasmReady;\r\n      edgeMap = wasmHysteresis(suppressed, width, height, finalLowThreshold, finalHighThreshold);\r\n    } catch (e) {\r\n      console.warn(\"WASM hysteresis failed, falling back to JS:\", e);\r\n      edgeMap = hysteresisThresholding(suppressed, width, height, finalLowThreshold, finalHighThreshold);\r\n    }\r\n  } else {\r\n    edgeMap = hysteresisThresholding(suppressed, width, height, finalLowThreshold, finalHighThreshold);\r\n  }\r\n  \r\n  t1 = performance.now();\r\n  timings.push({ step: 'Hysteresis', ms: (t1 - t0).toFixed(2) });\r\n\r\n  // Step 6: Create binary image (0 or 255)\r\n  t0 = performance.now();\r\n  const cannyEdges = new Uint8ClampedArray(width * height);\r\n  for (let i = 0; i < edgeMap.length; i++) {\r\n    cannyEdges[i] = edgeMap[i] === 2 ? 255 : 0;\r\n  }\r\n  t1 = performance.now();\r\n  timings.push({ step: 'Binary Image', ms: (t1 - t0).toFixed(2) });\r\n\r\n  // Step 7: Apply dilation if requested (matching jscanify)\r\n  t0 = performance.now();\r\n  let finalEdges = cannyEdges;\r\n  if (applyDilation) {\r\n    if (useWasmDilation) {\r\n      try {\r\n        await wasmReady; // Ensure wasm is initialized\r\n        finalEdges = wasmDilate(cannyEdges, width, height, dilationKernelSize);\r\n      } catch (e) {\r\n        finalEdges = dilateEdges(cannyEdges, width, height, dilationKernelSize);\r\n      }\r\n    } else {\r\n      finalEdges = dilateEdges(cannyEdges, width, height, dilationKernelSize);\r\n    }\r\n  }\r\n  t1 = performance.now();\r\n  timings.push({ step: 'Dilation', ms: (t1 - t0).toFixed(2) });\r\n\r\n  // Store debug info if requested\r\n  if (options.debug) {\r\n    options.debug.dx = dx; // Int16Array\r\n    options.debug.dy = dy; // Int16Array\r\n    // Calculate magnitude separately for debugging if needed\r\n     const magnitude = new Float32Array(width * height);\r\n     for (let i = 0; i < dx.length; i++) {\r\n         const gx = dx[i]; const gy = dy[i];\r\n         magnitude[i] = L2gradient ? Math.sqrt(gx * gx + gy * gy) : Math.abs(gx) + Math.abs(gy);\r\n     }\r\n     options.debug.magnitude = magnitude; // Float32Array (raw magnitude)\r\n    options.debug.suppressed = suppressed; // Float32Array (after NMS)\r\n    options.debug.edgeMap = edgeMap; // Uint8Array (0, 1, 2 values from hysteresis)\r\n    options.debug.cannyEdges = cannyEdges; // Uint8ClampedArray (0 or 255, before dilation)\r\n    options.debug.finalEdges = finalEdges; // Uint8ClampedArray (0 or 255, after dilation if applied)\r\n    options.debug.timings = timings;\r\n  }\r\n\r\n  const tEnd = performance.now();\r\n  timings.unshift({ step: 'Total', ms: (tEnd - tStart).toFixed(2) });\r\n  // Print timing table\r\n  console.table(timings);\r\n\r\n  return finalEdges; // Return the final binary edge image\r\n}\r\n\r\n/**\r\n * Full Canny edge detector implementation using WASM, for comparison or direct use\r\n * This function is intended to match the performance and output of the JS cannyEdgeDetector,\r\n * but runs entirely in WASM for potentially faster execution.\r\n * @param {ImageData} imageData - Original image data\r\n * @param {Object} options - Configuration options (same as cannyEdgeDetector)\r\n * @returns {Promise<Uint8ClampedArray>} Binary edge image (0 or 255)\r\n */\r\nexport async function cannyEdgeDetectorWasm(imageData, options = {}) {\r\n  // Directly call the WASM canny_edge_detector_full function\r\n  let result;\r\n  try {\r\n    await wasmReady; // Ensure wasm is initialized\r\n    console.log('Using WASM Full Canny');\r\n    result = wasmFullCanny(imageData.data, imageData.width, imageData.height, options.lowThreshold, options.highThreshold, options.sigma, options.kernelSize, options.L2gradient, options.applyDilation, options.dilationKernelSize);\r\n  } catch (e) {\r\n    console.error(\"WASM full Canny failed:\", e);\r\n    throw e; // Rethrow to let the caller handle the error\r\n  }\r\n  \r\n  // Convert result to Uint8ClampedArray (if not already)\r\n  const edges = new Uint8ClampedArray(result);\r\n  \r\n  return edges;\r\n}","/**\r\n * Enhanced Document Detection Module\r\n *\r\n * Provides OpenCV-level document detection with:\r\n * - CLAHE preprocessing for handling uneven lighting\r\n * - Sobel/Scharr gradient operators for better edge detection\r\n * - Adaptive thresholding\r\n * - Hough Line Transform for precise edge detection\r\n * - Document validation and confidence scoring\r\n * - Multi-candidate ranking\r\n */\r\n\r\nimport { DEFAULTS } from './constants.js';\r\nimport { convertToGrayscale } from './edgeDetection.js';\r\nimport init, {\r\n  // Core functions\r\n  blur as wasmBlur,\r\n  canny_edge_detector_full as wasmFullCanny,\r\n  dilate as wasmDilate,\r\n\r\n  // New enhanced functions\r\n  sobel_gradients_3x3 as wasmSobel3x3,\r\n  sobel_gradients_3x3_simd as wasmSobel3x3Simd,\r\n  scharr_gradients_3x3 as wasmScharr3x3,\r\n  sobel_gradients_5x5 as wasmSobel5x5,\r\n  gradient_magnitude_direction as wasmGradientMagDir,\r\n  nms_precise as wasmNmsPrecise,\r\n\r\n  // Adaptive thresholding\r\n  adaptive_threshold_mean as wasmAdaptiveThresholdMean,\r\n  adaptive_threshold_gaussian as wasmAdaptiveThresholdGaussian,\r\n  adaptive_threshold_sauvola as wasmAdaptiveThresholdSauvola,\r\n  compute_adaptive_canny_thresholds as wasmComputeCannyThresholds,\r\n  otsu_threshold as wasmOtsuThreshold,\r\n\r\n  // CLAHE and preprocessing\r\n  clahe as wasmClahe,\r\n  preprocess_document as wasmPreprocessDocument,\r\n  contrast_stretch as wasmContrastStretch,\r\n  illumination_normalize as wasmIlluminationNormalize,\r\n\r\n  // Hough transform\r\n  hough_lines as wasmHoughLines,\r\n  hough_lines_p as wasmHoughLinesP,\r\n  find_line_intersections as wasmFindIntersections,\r\n  find_document_quadrilateral as wasmFindQuadrilateral,\r\n\r\n  // Document validation\r\n  validate_quadrilateral as wasmValidateQuadrilateral,\r\n  calculate_edge_strength as wasmCalculateEdgeStrength,\r\n  calculate_size_score as wasmCalculateSizeScore,\r\n  calculate_detection_confidence as wasmCalculateConfidence,\r\n  refine_corners_subpixel as wasmRefineCorners,\r\n\r\n  // Morphological operations\r\n  morphological_close as wasmMorphClose,\r\n  morphological_open as wasmMorphOpen,\r\n  close_edge_gaps as wasmCloseEdgeGaps,\r\n  remove_small_components as wasmRemoveSmallComponents,\r\n  thin_edges as wasmThinEdges,\r\n} from '../wasm_blur/pkg/wasm_blur.js';\r\n\r\n// Initialize WASM\r\nconst wasmReady = init();\r\n\r\n/**\r\n * Detection pipeline configuration\r\n */\r\nexport const DETECTION_PRESETS = {\r\n  // Fast detection with reasonable accuracy\r\n  fast: {\r\n    preprocessing: {\r\n      enableClahe: false,\r\n      enableIlluminationNorm: false,\r\n    },\r\n    edge: {\r\n      gradientOperator: 'sobel3x3',\r\n      adaptiveThreshold: false,\r\n      lowThreshold: 50,\r\n      highThreshold: 150,\r\n    },\r\n    postprocessing: {\r\n      closeGaps: false,\r\n      removeNoise: false,\r\n    },\r\n    detection: {\r\n      useHoughLines: false,\r\n      minConfidence: 0.3,\r\n    },\r\n  },\r\n\r\n  // Balanced detection (recommended for most cases)\r\n  balanced: {\r\n    preprocessing: {\r\n      enableClahe: true,\r\n      claheClip: 2.0,\r\n      claheGrid: 8,\r\n      enableIlluminationNorm: false,\r\n    },\r\n    edge: {\r\n      gradientOperator: 'sobel3x3',\r\n      adaptiveThreshold: true,\r\n      adaptiveMethod: 'percentile', // 'fixed', 'otsu', 'percentile'\r\n    },\r\n    postprocessing: {\r\n      closeGaps: true,\r\n      gapSize: 5,\r\n      removeNoise: true,\r\n      minComponentArea: 100,\r\n    },\r\n    detection: {\r\n      useHoughLines: true,\r\n      houghThreshold: 50,\r\n      minLineLength: 30,\r\n      maxLineGap: 10,\r\n      minConfidence: 0.4,\r\n    },\r\n  },\r\n\r\n  // High accuracy detection (slower but more reliable)\r\n  accurate: {\r\n    preprocessing: {\r\n      enableClahe: true,\r\n      claheClip: 2.5,\r\n      claheGrid: 8,\r\n      enableIlluminationNorm: true,\r\n    },\r\n    edge: {\r\n      gradientOperator: 'scharr3x3', // Better rotational accuracy\r\n      adaptiveThreshold: true,\r\n      adaptiveMethod: 'percentile',\r\n    },\r\n    postprocessing: {\r\n      closeGaps: true,\r\n      gapSize: 7,\r\n      removeNoise: true,\r\n      minComponentArea: 150,\r\n      thinEdges: true,\r\n    },\r\n    detection: {\r\n      useHoughLines: true,\r\n      houghThreshold: 30,\r\n      minLineLength: 20,\r\n      maxLineGap: 15,\r\n      minConfidence: 0.5,\r\n      refineCorners: true,\r\n    },\r\n  },\r\n\r\n  // ID document optimized (passports, driver's licenses, ID cards)\r\n  idDocument: {\r\n    preprocessing: {\r\n      enableClahe: true,\r\n      claheClip: 3.0,\r\n      claheGrid: 8,\r\n      enableIlluminationNorm: true,\r\n    },\r\n    edge: {\r\n      gradientOperator: 'scharr3x3',\r\n      adaptiveThreshold: true,\r\n      adaptiveMethod: 'percentile',\r\n    },\r\n    postprocessing: {\r\n      closeGaps: true,\r\n      gapSize: 5,\r\n      removeNoise: true,\r\n      minComponentArea: 100,\r\n    },\r\n    detection: {\r\n      useHoughLines: true,\r\n      houghThreshold: 40,\r\n      minLineLength: 25,\r\n      maxLineGap: 10,\r\n      minConfidence: 0.5,\r\n      refineCorners: true,\r\n      // ID documents have specific aspect ratios\r\n      validateAspectRatio: true,\r\n      expectedAspectRatios: [1.586, 1.42], // CR-80, Passport\r\n      aspectTolerance: 0.15,\r\n    },\r\n  },\r\n};\r\n\r\n/**\r\n * Enhanced preprocessing pipeline\r\n */\r\nasync function preprocessImage(grayscale, width, height, options) {\r\n  await wasmReady;\r\n\r\n  let processed = grayscale;\r\n  const timings = [];\r\n\r\n  // Step 1: Illumination normalization\r\n  if (options.enableIlluminationNorm) {\r\n    const t0 = performance.now();\r\n    const sigma = Math.min(width, height) / 10;\r\n    processed = wasmIlluminationNormalize(processed, width, height, sigma);\r\n    timings.push({ step: 'Illumination Norm', ms: (performance.now() - t0).toFixed(2) });\r\n  }\r\n\r\n  // Step 2: CLAHE\r\n  if (options.enableClahe) {\r\n    const t0 = performance.now();\r\n    processed = wasmClahe(\r\n      processed,\r\n      width,\r\n      height,\r\n      options.claheGrid || 8,\r\n      options.claheGrid || 8,\r\n      options.claheClip || 2.0\r\n    );\r\n    timings.push({ step: 'CLAHE', ms: (performance.now() - t0).toFixed(2) });\r\n  }\r\n\r\n  // Step 3: Contrast stretch\r\n  if (options.enableContrastStretch) {\r\n    const t0 = performance.now();\r\n    processed = wasmContrastStretch(processed, width, height);\r\n    timings.push({ step: 'Contrast Stretch', ms: (performance.now() - t0).toFixed(2) });\r\n  }\r\n\r\n  return { processed, timings };\r\n}\r\n\r\n/**\r\n * Enhanced gradient calculation\r\n */\r\nasync function calculateGradients(blurred, width, height, options) {\r\n  await wasmReady;\r\n\r\n  const operator = options.gradientOperator || 'sobel3x3';\r\n  let gradients;\r\n\r\n  const t0 = performance.now();\r\n\r\n  switch (operator) {\r\n    case 'scharr3x3':\r\n      gradients = wasmScharr3x3(blurred, width, height);\r\n      break;\r\n    case 'sobel5x5':\r\n      gradients = wasmSobel5x5(blurred, width, height);\r\n      break;\r\n    case 'sobel3x3_simd':\r\n      gradients = wasmSobel3x3Simd(blurred, width, height);\r\n      break;\r\n    case 'sobel3x3':\r\n    default:\r\n      gradients = wasmSobel3x3(blurred, width, height);\r\n      break;\r\n  }\r\n\r\n  const elapsed = performance.now() - t0;\r\n\r\n  return { gradients, elapsed };\r\n}\r\n\r\n/**\r\n * Compute adaptive Canny thresholds\r\n */\r\nasync function computeAdaptiveThresholds(magnitude, width, height, options) {\r\n  await wasmReady;\r\n\r\n  const method = options.adaptiveMethod || 'percentile';\r\n\r\n  switch (method) {\r\n    case 'otsu': {\r\n      // Use Otsu's method on magnitude histogram\r\n      const magnitudeU8 = new Uint8Array(magnitude.length);\r\n      const maxMag = Math.max(...magnitude);\r\n      for (let i = 0; i < magnitude.length; i++) {\r\n        magnitudeU8[i] = Math.min(255, Math.floor(magnitude[i] / maxMag * 255));\r\n      }\r\n      const otsuThresh = wasmOtsuThreshold(magnitudeU8, width, height);\r\n      return {\r\n        low: otsuThresh * 0.4 * maxMag / 255,\r\n        high: otsuThresh * maxMag / 255,\r\n      };\r\n    }\r\n\r\n    case 'percentile':\r\n    default: {\r\n      const thresholds = wasmComputeCannyThresholds(magnitude, width, height, 0.4, 0.7);\r\n      return {\r\n        low: thresholds[0],\r\n        high: thresholds[1],\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Enhanced edge detection with all improvements\r\n */\r\nexport async function enhancedEdgeDetection(imageData, options = {}) {\r\n  await wasmReady;\r\n\r\n  const { width, height } = imageData;\r\n  const config = options.preset ? DETECTION_PRESETS[options.preset] : options;\r\n  const preprocessing = config.preprocessing || {};\r\n  const edgeConfig = config.edge || {};\r\n  const postConfig = config.postprocessing || {};\r\n\r\n  const timings = [];\r\n  const debug = options.debug ? {} : null;\r\n\r\n  // Step 1: Convert to grayscale\r\n  let t0 = performance.now();\r\n  const grayscale = convertToGrayscale(imageData);\r\n  timings.push({ step: 'Grayscale', ms: (performance.now() - t0).toFixed(2) });\r\n\r\n  if (debug) debug.grayscale = grayscale;\r\n\r\n  // Step 2: Preprocessing\r\n  const { processed, timings: prepTimings } = await preprocessImage(\r\n    grayscale, width, height, preprocessing\r\n  );\r\n  timings.push(...prepTimings);\r\n\r\n  if (debug) debug.preprocessed = processed;\r\n\r\n  // Step 3: Gaussian blur\r\n  t0 = performance.now();\r\n  const kernelSize = edgeConfig.kernelSize || 5;\r\n  const sigma = edgeConfig.sigma || 0;\r\n  const blurred = wasmBlur(processed, width, height, kernelSize, sigma);\r\n  timings.push({ step: 'Gaussian Blur', ms: (performance.now() - t0).toFixed(2) });\r\n\r\n  if (debug) debug.blurred = blurred;\r\n\r\n  // Step 4: Calculate gradients using enhanced operators\r\n  const { gradients, elapsed: gradientTime } = await calculateGradients(\r\n    blurred, width, height, edgeConfig\r\n  );\r\n  timings.push({ step: 'Gradients', ms: gradientTime.toFixed(2) });\r\n\r\n  // Step 5: Compute magnitude and direction\r\n  t0 = performance.now();\r\n  const magDir = wasmGradientMagDir(gradients, width, height, true);\r\n  const magnitude = new Float32Array(width * height);\r\n  const direction = new Float32Array(width * height);\r\n  for (let i = 0; i < width * height; i++) {\r\n    magnitude[i] = magDir[2 * i];\r\n    direction[i] = magDir[2 * i + 1];\r\n  }\r\n  timings.push({ step: 'Magnitude/Direction', ms: (performance.now() - t0).toFixed(2) });\r\n\r\n  if (debug) {\r\n    debug.magnitude = magnitude;\r\n    debug.direction = direction;\r\n    debug.gradients = gradients;\r\n  }\r\n\r\n  // Step 6: Non-maximum suppression with precise direction\r\n  t0 = performance.now();\r\n  const suppressed = wasmNmsPrecise(magnitude, direction, width, height);\r\n  timings.push({ step: 'NMS (Precise)', ms: (performance.now() - t0).toFixed(2) });\r\n\r\n  if (debug) debug.suppressed = suppressed;\r\n\r\n  // Step 7: Compute adaptive thresholds or use fixed\r\n  let lowThreshold = edgeConfig.lowThreshold || 50;\r\n  let highThreshold = edgeConfig.highThreshold || 150;\r\n\r\n  if (edgeConfig.adaptiveThreshold) {\r\n    t0 = performance.now();\r\n    const adaptive = await computeAdaptiveThresholds(suppressed, width, height, edgeConfig);\r\n    lowThreshold = adaptive.low;\r\n    highThreshold = adaptive.high;\r\n    timings.push({ step: 'Adaptive Threshold', ms: (performance.now() - t0).toFixed(2) });\r\n\r\n    if (debug) {\r\n      debug.adaptiveThresholds = { low: lowThreshold, high: highThreshold };\r\n    }\r\n  }\r\n\r\n  // Step 8: Hysteresis thresholding (use full Canny from this point)\r\n  t0 = performance.now();\r\n\r\n  // Create binary edge map from suppressed\r\n  const edgeMap = new Uint8Array(width * height);\r\n  for (let i = 0; i < suppressed.length; i++) {\r\n    if (suppressed[i] >= highThreshold) {\r\n      edgeMap[i] = 255;\r\n    } else if (suppressed[i] >= lowThreshold) {\r\n      edgeMap[i] = 128; // Weak edge\r\n    }\r\n  }\r\n\r\n  // Connect weak edges to strong edges (simple hysteresis)\r\n  const finalEdges = performHysteresis(edgeMap, width, height);\r\n  timings.push({ step: 'Hysteresis', ms: (performance.now() - t0).toFixed(2) });\r\n\r\n  if (debug) debug.beforePost = new Uint8Array(finalEdges);\r\n\r\n  // Step 9: Post-processing\r\n  let postProcessed = finalEdges;\r\n\r\n  if (postConfig.closeGaps) {\r\n    t0 = performance.now();\r\n    postProcessed = wasmCloseEdgeGaps(postProcessed, width, height, postConfig.gapSize || 5);\r\n    timings.push({ step: 'Close Gaps', ms: (performance.now() - t0).toFixed(2) });\r\n  }\r\n\r\n  if (postConfig.removeNoise) {\r\n    t0 = performance.now();\r\n    postProcessed = wasmRemoveSmallComponents(\r\n      postProcessed, width, height, postConfig.minComponentArea || 100\r\n    );\r\n    timings.push({ step: 'Remove Noise', ms: (performance.now() - t0).toFixed(2) });\r\n  }\r\n\r\n  if (postConfig.thinEdges) {\r\n    t0 = performance.now();\r\n    postProcessed = wasmThinEdges(postProcessed, width, height);\r\n    timings.push({ step: 'Thin Edges', ms: (performance.now() - t0).toFixed(2) });\r\n  }\r\n\r\n  if (debug) {\r\n    debug.finalEdges = postProcessed;\r\n    debug.timings = timings;\r\n  }\r\n\r\n  console.table(timings);\r\n\r\n  return {\r\n    edges: new Uint8ClampedArray(postProcessed),\r\n    gradients,\r\n    magnitude,\r\n    direction,\r\n    debug,\r\n  };\r\n}\r\n\r\n/**\r\n * Simple hysteresis implementation\r\n */\r\nfunction performHysteresis(edgeMap, width, height) {\r\n  const output = new Uint8Array(width * height);\r\n  const visited = new Uint8Array(width * height);\r\n  const stack = [];\r\n\r\n  // Find strong edges\r\n  for (let i = 0; i < edgeMap.length; i++) {\r\n    if (edgeMap[i] === 255) {\r\n      output[i] = 255;\r\n      stack.push(i);\r\n    }\r\n  }\r\n\r\n  // Propagate to connected weak edges\r\n  const offsets = [-width - 1, -width, -width + 1, -1, 1, width - 1, width, width + 1];\r\n\r\n  while (stack.length > 0) {\r\n    const idx = stack.pop();\r\n    const x = idx % width;\r\n    const y = Math.floor(idx / width);\r\n\r\n    for (const offset of offsets) {\r\n      const nidx = idx + offset;\r\n      const nx = nidx % width;\r\n\r\n      // Check bounds and avoid wrap-around\r\n      if (nidx >= 0 && nidx < edgeMap.length &&\r\n          Math.abs(nx - x) <= 1 && !visited[nidx]) {\r\n        visited[nidx] = 1;\r\n\r\n        if (edgeMap[nidx] === 128) { // Weak edge\r\n          output[nidx] = 255;\r\n          stack.push(nidx);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return output;\r\n}\r\n\r\n/**\r\n * Detect document using Hough Line Transform\r\n */\r\nexport async function detectDocumentHough(edges, width, height, options = {}) {\r\n  await wasmReady;\r\n\r\n  const config = options.detection || options;\r\n  const timings = [];\r\n\r\n  // Step 1: Hough Line Transform\r\n  let t0 = performance.now();\r\n  const lines = wasmHoughLines(\r\n    edges,\r\n    width,\r\n    height,\r\n    1.0, // rho resolution\r\n    1.0, // theta resolution (degrees)\r\n    config.houghThreshold || 50,\r\n    100  // max lines\r\n  );\r\n  timings.push({ step: 'Hough Lines', ms: (performance.now() - t0).toFixed(2) });\r\n\r\n  const numLines = lines.length / 3;\r\n  console.log(`Detected ${numLines} lines`);\r\n\r\n  if (numLines < 4) {\r\n    return {\r\n      success: false,\r\n      message: 'Not enough lines detected',\r\n      timings,\r\n    };\r\n  }\r\n\r\n  // Step 2: Find document quadrilateral\r\n  t0 = performance.now();\r\n  const quad = wasmFindQuadrilateral(\r\n    lines,\r\n    width,\r\n    height,\r\n    config.minAreaRatio || 0.05,\r\n    config.maxAreaRatio || 0.95\r\n  );\r\n  timings.push({ step: 'Find Quadrilateral', ms: (performance.now() - t0).toFixed(2) });\r\n\r\n  if (quad.length === 0) {\r\n    return {\r\n      success: false,\r\n      message: 'No valid quadrilateral found',\r\n      lines: parseLines(lines),\r\n      timings,\r\n    };\r\n  }\r\n\r\n  // Extract corners and confidence\r\n  const corners = {\r\n    topLeft: { x: quad[0], y: quad[1] },\r\n    topRight: { x: quad[2], y: quad[3] },\r\n    bottomRight: { x: quad[4], y: quad[5] },\r\n    bottomLeft: { x: quad[6], y: quad[7] },\r\n  };\r\n  const lineConfidence = quad[8];\r\n\r\n  // Step 3: Validate quadrilateral\r\n  t0 = performance.now();\r\n  const validation = wasmValidateQuadrilateral(new Float32Array([\r\n    quad[0], quad[1], quad[2], quad[3], quad[4], quad[5], quad[6], quad[7]\r\n  ]));\r\n  timings.push({ step: 'Validate Quad', ms: (performance.now() - t0).toFixed(2) });\r\n\r\n  const validationResult = {\r\n    shapeScore: validation[0],\r\n    convexityScore: validation[1],\r\n    angleScore: validation[2],\r\n    parallelismScore: validation[3],\r\n    aspectRatio: validation[4],\r\n    aspectScore: validation[5],\r\n    documentType: ['unknown', 'id_card', 'passport', 'paper'][validation[6]] || 'unknown',\r\n  };\r\n\r\n  // Step 4: Calculate size score\r\n  const sizeScore = wasmCalculateSizeScore(\r\n    new Float32Array([quad[0], quad[1], quad[2], quad[3], quad[4], quad[5], quad[6], quad[7]]),\r\n    width,\r\n    height,\r\n    0.05, // min coverage\r\n    0.95, // max coverage\r\n    0.3   // ideal coverage\r\n  );\r\n\r\n  // Step 5: Calculate overall confidence\r\n  const confidence = wasmCalculateConfidence(\r\n    lineConfidence / 100, // Normalize line confidence\r\n    validationResult.shapeScore,\r\n    validationResult.aspectScore,\r\n    sizeScore\r\n  );\r\n\r\n  console.table(timings);\r\n\r\n  return {\r\n    success: confidence >= (config.minConfidence || 0.4),\r\n    corners,\r\n    confidence,\r\n    validation: validationResult,\r\n    sizeScore,\r\n    lines: parseLines(lines),\r\n    timings,\r\n  };\r\n}\r\n\r\n/**\r\n * Parse flat line array into structured format\r\n */\r\nfunction parseLines(lines) {\r\n  const result = [];\r\n  for (let i = 0; i < lines.length; i += 3) {\r\n    result.push({\r\n      rho: lines[i],\r\n      theta: lines[i + 1],\r\n      thetaDegrees: lines[i + 1] * 180 / Math.PI,\r\n      votes: lines[i + 2],\r\n    });\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Complete enhanced document detection pipeline\r\n */\r\nexport async function enhancedDocumentDetection(imageData, options = {}) {\r\n  await wasmReady;\r\n\r\n  const preset = options.preset || 'balanced';\r\n  const config = DETECTION_PRESETS[preset] || DETECTION_PRESETS.balanced;\r\n\r\n  // Merge options with preset\r\n  const mergedConfig = {\r\n    ...config,\r\n    ...options,\r\n    preprocessing: { ...config.preprocessing, ...options.preprocessing },\r\n    edge: { ...config.edge, ...options.edge },\r\n    postprocessing: { ...config.postprocessing, ...options.postprocessing },\r\n    detection: { ...config.detection, ...options.detection },\r\n  };\r\n\r\n  const { width, height } = imageData;\r\n  const debug = options.debug ? {} : null;\r\n\r\n  // Step 1: Enhanced edge detection\r\n  const edgeResult = await enhancedEdgeDetection(imageData, {\r\n    ...mergedConfig,\r\n    debug: debug ? {} : null,\r\n  });\r\n\r\n  if (debug) {\r\n    debug.edgeDetection = edgeResult.debug;\r\n  }\r\n\r\n  // Step 2: Document detection using Hough or contour method\r\n  let detection;\r\n\r\n  if (mergedConfig.detection.useHoughLines) {\r\n    detection = await detectDocumentHough(\r\n      edgeResult.edges,\r\n      width,\r\n      height,\r\n      mergedConfig\r\n    );\r\n\r\n    // If Hough fails, fall back to contour detection\r\n    if (!detection.success) {\r\n      console.log('Hough detection failed, trying contour detection...');\r\n      // Import and use the existing contour detection\r\n      const { detectDocumentContour } = await import('./contourDetection.js');\r\n      const { findCornerPoints } = await import('./cornerDetection.js');\r\n\r\n      const contours = detectDocumentContour(edgeResult.edges, {\r\n        minArea: 1000,\r\n        width,\r\n        height,\r\n      });\r\n\r\n      if (contours && contours.length > 0) {\r\n        const corners = findCornerPoints(contours[0]);\r\n\r\n        // Validate the contour-detected corners\r\n        const cornersArray = new Float32Array([\r\n          corners.topLeft.x, corners.topLeft.y,\r\n          corners.topRight.x, corners.topRight.y,\r\n          corners.bottomRight.x, corners.bottomRight.y,\r\n          corners.bottomLeft.x, corners.bottomLeft.y,\r\n        ]);\r\n\r\n        const validation = wasmValidateQuadrilateral(cornersArray);\r\n        const sizeScore = wasmCalculateSizeScore(cornersArray, width, height, 0.05, 0.95, 0.3);\r\n\r\n        // Calculate edge strength using gradients\r\n        const edgeScore = wasmCalculateEdgeStrength(\r\n          edgeResult.gradients,\r\n          width,\r\n          height,\r\n          cornersArray,\r\n          20 // sample points\r\n        );\r\n\r\n        const confidence = wasmCalculateConfidence(edgeScore, validation[0], validation[5], sizeScore);\r\n\r\n        detection = {\r\n          success: confidence >= (mergedConfig.detection.minConfidence || 0.4),\r\n          corners,\r\n          confidence,\r\n          validation: {\r\n            shapeScore: validation[0],\r\n            convexityScore: validation[1],\r\n            angleScore: validation[2],\r\n            parallelismScore: validation[3],\r\n            aspectRatio: validation[4],\r\n            aspectScore: validation[5],\r\n            documentType: ['unknown', 'id_card', 'passport', 'paper'][validation[6]] || 'unknown',\r\n          },\r\n          sizeScore,\r\n          edgeScore,\r\n          method: 'contour',\r\n        };\r\n      }\r\n    } else {\r\n      detection.method = 'hough';\r\n    }\r\n  } else {\r\n    // Use contour detection directly\r\n    const { detectDocumentContour } = await import('./contourDetection.js');\r\n    const { findCornerPoints } = await import('./cornerDetection.js');\r\n\r\n    const contours = detectDocumentContour(edgeResult.edges, {\r\n      minArea: 1000,\r\n      width,\r\n      height,\r\n    });\r\n\r\n    if (contours && contours.length > 0) {\r\n      const corners = findCornerPoints(contours[0]);\r\n\r\n      const cornersArray = new Float32Array([\r\n        corners.topLeft.x, corners.topLeft.y,\r\n        corners.topRight.x, corners.topRight.y,\r\n        corners.bottomRight.x, corners.bottomRight.y,\r\n        corners.bottomLeft.x, corners.bottomLeft.y,\r\n      ]);\r\n\r\n      const validation = wasmValidateQuadrilateral(cornersArray);\r\n      const sizeScore = wasmCalculateSizeScore(cornersArray, width, height, 0.05, 0.95, 0.3);\r\n      const edgeScore = wasmCalculateEdgeStrength(edgeResult.gradients, width, height, cornersArray, 20);\r\n      const confidence = wasmCalculateConfidence(edgeScore, validation[0], validation[5], sizeScore);\r\n\r\n      detection = {\r\n        success: confidence >= (mergedConfig.detection.minConfidence || 0.4),\r\n        corners,\r\n        confidence,\r\n        validation: {\r\n          shapeScore: validation[0],\r\n          convexityScore: validation[1],\r\n          angleScore: validation[2],\r\n          parallelismScore: validation[3],\r\n          aspectRatio: validation[4],\r\n          aspectScore: validation[5],\r\n          documentType: ['unknown', 'id_card', 'passport', 'paper'][validation[6]] || 'unknown',\r\n        },\r\n        sizeScore,\r\n        edgeScore,\r\n        method: 'contour',\r\n      };\r\n    } else {\r\n      detection = {\r\n        success: false,\r\n        message: 'No document contours found',\r\n      };\r\n    }\r\n  }\r\n\r\n  // Step 3: Refine corners if enabled and detection succeeded\r\n  if (detection.success && mergedConfig.detection.refineCorners && detection.corners) {\r\n    const cornersArray = new Float32Array([\r\n      detection.corners.topLeft.x, detection.corners.topLeft.y,\r\n      detection.corners.topRight.x, detection.corners.topRight.y,\r\n      detection.corners.bottomRight.x, detection.corners.bottomRight.y,\r\n      detection.corners.bottomLeft.x, detection.corners.bottomLeft.y,\r\n    ]);\r\n\r\n    const refined = wasmRefineCorners(edgeResult.gradients, width, height, cornersArray, 5);\r\n\r\n    detection.corners = {\r\n      topLeft: { x: refined[0], y: refined[1] },\r\n      topRight: { x: refined[2], y: refined[3] },\r\n      bottomRight: { x: refined[4], y: refined[5] },\r\n      bottomLeft: { x: refined[6], y: refined[7] },\r\n    };\r\n    detection.cornersRefined = true;\r\n  }\r\n\r\n  if (debug) {\r\n    debug.detection = detection;\r\n    debug.edges = edgeResult.edges;\r\n  }\r\n\r\n  return {\r\n    ...detection,\r\n    edges: edgeResult.edges,\r\n    debug,\r\n  };\r\n}\r\n\r\n/**\r\n * Quick document detection for live camera preview\r\n * Uses fastest settings for real-time performance\r\n */\r\nexport async function quickDocumentDetection(imageData, options = {}) {\r\n  return enhancedDocumentDetection(imageData, {\r\n    preset: 'fast',\r\n    ...options,\r\n  });\r\n}\r\n\r\n/**\r\n * ID document detection optimized for passports and ID cards\r\n */\r\nexport async function detectIDDocument(imageData, options = {}) {\r\n  return enhancedDocumentDetection(imageData, {\r\n    preset: 'idDocument',\r\n    ...options,\r\n  });\r\n}\r\n\r\n// Export presets for customization\r\nexport { DETECTION_PRESETS as presets };\r\n","/**\r\n * scanic\r\n * JavaScript document scanner without OpenCV dependency\r\n * MIT License\r\n */\r\n\r\n\r\nimport { detectDocumentContour } from './contourDetection.js';\r\nimport { findCornerPoints } from './cornerDetection.js';\r\nimport { cannyEdgeDetector } from './edgeDetection.js';\r\n\r\n\r\n// Helper function to calculate smart adaptive downscale factor\r\nfunction calculateAdaptiveDownscale(imageData, maxDimension = 800) {\r\n  const { width, height } = imageData;\r\n  const maxCurrentDimension = Math.max(width, height);\r\n  \r\n  // If image is already smaller than target, no scaling needed\r\n  if (maxCurrentDimension <= maxDimension) {\r\n    return {\r\n      scaledImageData: imageData,\r\n      scaleFactor: 1,\r\n      originalDimensions: { width, height },\r\n      scaledDimensions: { width, height }\r\n    };\r\n  }\r\n  \r\n  // Calculate scale factor to fit within maxDimension\r\n  const scaleFactor = maxDimension / maxCurrentDimension;\r\n  const scaledWidth = Math.round(width * scaleFactor);\r\n  const scaledHeight = Math.round(height * scaleFactor);\r\n  \r\n  // Create scaled image data\r\n  const tempCanvas = document.createElement('canvas');\r\n  tempCanvas.width = width;\r\n  tempCanvas.height = height;\r\n  const tempCtx = tempCanvas.getContext('2d');\r\n  tempCtx.putImageData(imageData, 0, 0);\r\n\r\n  const scaledCanvas = document.createElement('canvas');\r\n  scaledCanvas.width = scaledWidth;\r\n  scaledCanvas.height = scaledHeight;\r\n  const scaledCtx = scaledCanvas.getContext('2d');\r\n  \r\n  // Use high-quality scaling\r\n  scaledCtx.imageSmoothingEnabled = true;\r\n  scaledCtx.imageSmoothingQuality = 'high';\r\n  scaledCtx.drawImage(tempCanvas, 0, 0, width, height, 0, 0, scaledWidth, scaledHeight);\r\n  \r\n  const scaledImageData = scaledCtx.getImageData(0, 0, scaledWidth, scaledHeight);\r\n  \r\n  return {\r\n    scaledImageData,\r\n    scaleFactor: 1 / scaleFactor, // Return inverse for compatibility with existing code\r\n    originalDimensions: { width, height },\r\n    scaledDimensions: { width: scaledWidth, height: scaledHeight }\r\n  };\r\n}\r\n\r\n// Internal function to detect document in image\r\nasync function detectDocumentInternal(imageData, options = {}) {\r\n  const debugInfo = options.debug ? {} : null;\r\n  \r\n  // Smart adaptive downscaling - ensure largest dimension doesn't exceed maxProcessingDimension\r\n  const maxProcessingDimension = options.maxProcessingDimension || 800;\r\n  const { scaledImageData, scaleFactor, originalDimensions, scaledDimensions } = \r\n    calculateAdaptiveDownscale(imageData, maxProcessingDimension);\r\n  \r\n  if (debugInfo) {\r\n    debugInfo.preprocessing = {\r\n      originalDimensions,\r\n      scaledDimensions,\r\n      scaleFactor,\r\n      maxProcessingDimension\r\n    };\r\n  }\r\n  \r\n  const { width, height } = scaledImageData; // Use scaled dimensions\r\n  \r\n  // Run edge detection on the adaptively scaled image\r\n  const edges = await cannyEdgeDetector(scaledImageData, {\r\n    lowThreshold: options.lowThreshold || 75,   // Match OpenCV values\r\n    highThreshold: options.highThreshold || 200, // Match OpenCV values\r\n    dilationKernelSize: options.dilationKernelSize || 3, // Match OpenCV value \r\n    dilationIterations: options.dilationIterations || 1,\r\n    debug: debugInfo,\r\n    skipNMS: false, // options.skipNMS // Optional flag to skip non-max suppression\r\n    useWasmBlur: true, // option to use wasm blur\r\n  });\r\n  \r\n  // Detect contours from edges\r\n  const contours = detectDocumentContour(edges, {\r\n    minArea: (options.minArea || 1000) / (scaleFactor * scaleFactor), // Adjust minArea for scaled image\r\n    debug: debugInfo,\r\n    width: width,     \r\n    height: height    \r\n  });\r\n\r\n  if (!contours || contours.length === 0) {\r\n    console.log('No document detected');\r\n    return {\r\n      success: false,\r\n      message: 'No document detected',\r\n      debug: debugInfo\r\n    };\r\n  }\r\n  \r\n  // Get the largest contour which is likely the document\r\n  const documentContour = contours[0]; \r\n  \r\n  // Find corner points on the scaled image\r\n  const cornerPoints = findCornerPoints(documentContour, { \r\n      epsilon: options.epsilon // Pass epsilon for approximation\r\n  });\r\n  \r\n  // Scale corner points back to original image size\r\n  let finalCorners = cornerPoints;\r\n  if (scaleFactor !== 1) {\r\n    finalCorners = {\r\n      topLeft: { x: cornerPoints.topLeft.x * scaleFactor, y: cornerPoints.topLeft.y * scaleFactor },\r\n      topRight: { x: cornerPoints.topRight.x * scaleFactor, y: cornerPoints.topRight.y * scaleFactor },\r\n      bottomRight: { x: cornerPoints.bottomRight.x * scaleFactor, y: cornerPoints.bottomRight.y * scaleFactor },\r\n      bottomLeft: { x: cornerPoints.bottomLeft.x * scaleFactor, y: cornerPoints.bottomLeft.y * scaleFactor },\r\n    };\r\n  }\r\n  \r\n  // Return the result, scaling the contour points back up as well\r\n  return {\r\n    success: true,\r\n    contour: documentContour,\r\n    corners: finalCorners,\r\n    debug: debugInfo\r\n  };\r\n}\r\n\r\n// --- Perspective transform helpers (internal use only) ---\r\nfunction getPerspectiveTransform(srcPoints, dstPoints) {\r\n  // Helper to build the system of equations\r\n  function buildMatrix(points) {\r\n    const matrix = [];\r\n    for (let i = 0; i < 4; i++) {\r\n      const [x, y] = points[i];\r\n      matrix.push([x, y, 1, 0, 0, 0, -x * dstPoints[i][0], -y * dstPoints[i][0]]);\r\n      matrix.push([0, 0, 0, x, y, 1, -x * dstPoints[i][1], -y * dstPoints[i][1]]);\r\n    }\r\n    return matrix;\r\n  }\r\n\r\n  const A = buildMatrix(srcPoints);\r\n  const b = [\r\n    dstPoints[0][0], dstPoints[0][1],\r\n    dstPoints[1][0], dstPoints[1][1],\r\n    dstPoints[2][0], dstPoints[2][1],\r\n    dstPoints[3][0], dstPoints[3][1]\r\n  ];\r\n\r\n  // Solve Ah = b for h (h is 8x1, last element is 1)\r\n  // Use Gaussian elimination or Cramer's rule for 8x8\r\n  // For simplicity, use numeric.js if available, else implement basic solver\r\n  function solve(A, b) {\r\n    // Gaussian elimination for 8x8\r\n    const m = A.length;\r\n    const n = A[0].length;\r\n    const M = A.map(row => row.slice());\r\n    const B = b.slice();\r\n\r\n    for (let i = 0; i < n; i++) {\r\n      // Find max row\r\n      let maxRow = i;\r\n      for (let k = i + 1; k < m; k++) {\r\n        if (Math.abs(M[k][i]) > Math.abs(M[maxRow][i])) maxRow = k;\r\n      }\r\n      // Swap rows\r\n      [M[i], M[maxRow]] = [M[maxRow], M[i]];\r\n      [B[i], B[maxRow]] = [B[maxRow], B[i]];\r\n\r\n      // Eliminate\r\n      for (let k = i + 1; k < m; k++) {\r\n        const c = M[k][i] / M[i][i];\r\n        for (let j = i; j < n; j++) {\r\n          M[k][j] -= c * M[i][j];\r\n        }\r\n        B[k] -= c * B[i];\r\n      }\r\n    }\r\n\r\n    // Back substitution\r\n    const x = new Array(n);\r\n    for (let i = n - 1; i >= 0; i--) {\r\n      let sum = B[i];\r\n      for (let j = i + 1; j < n; j++) {\r\n        sum -= M[i][j] * x[j];\r\n      }\r\n      x[i] = sum / M[i][i];\r\n    }\r\n    return x;\r\n  }\r\n\r\n  const h = solve(A, b);\r\n  // h is [h0,h1,h2,h3,h4,h5,h6,h7], h8 = 1\r\n  const matrix = [\r\n    [h[0], h[1], h[2]],\r\n    [h[3], h[4], h[5]],\r\n    [h[6], h[7], 1]\r\n  ];\r\n  return matrix;\r\n}\r\n\r\n\r\n\r\n\r\nfunction unwarpImage(ctx, image, corners) {\r\n  // Get perspective transform matrix\r\n  const { topLeft, topRight, bottomRight, bottomLeft } = corners;\r\n  // Compute output rectangle size\r\n  const widthA = Math.hypot(bottomRight.x - bottomLeft.x, bottomRight.y - bottomLeft.y);\r\n  const widthB = Math.hypot(topRight.x - topLeft.x, topRight.y - topLeft.y);\r\n  const maxWidth = Math.round(Math.max(widthA, widthB));\r\n  const heightA = Math.hypot(topRight.x - bottomRight.x, topRight.y - bottomRight.y);\r\n  const heightB = Math.hypot(topLeft.x - bottomLeft.x, topLeft.y - bottomLeft.y);\r\n  const maxHeight = Math.round(Math.max(heightA, heightB));\r\n\r\n  // Set output canvas size\r\n  ctx.canvas.width = maxWidth;\r\n  ctx.canvas.height = maxHeight;\r\n\r\n  const srcPoints = [\r\n    [topLeft.x, topLeft.y],\r\n    [topRight.x, topRight.y],\r\n    [bottomRight.x, bottomRight.y],\r\n    [bottomLeft.x, bottomLeft.y]\r\n  ];\r\n  const dstPoints = [\r\n    [0, 0],\r\n    [maxWidth - 1, 0],\r\n    [maxWidth - 1, maxHeight - 1],\r\n    [0, maxHeight - 1]\r\n  ];\r\n  const perspectiveMatrix = getPerspectiveTransform(srcPoints, dstPoints);\r\n  warpTransform(ctx, image, perspectiveMatrix, maxWidth, maxHeight);\r\n}\r\n\r\nfunction invert3x3(m) {\r\n  // Invert a 3x3 matrix\r\n  const a = m[0][0], b = m[0][1], c = m[0][2];\r\n  const d = m[1][0], e = m[1][1], f = m[1][2];\r\n  const g = m[2][0], h = m[2][1], i = m[2][2];\r\n  const A = e * i - f * h;\r\n  const B = -(d * i - f * g);\r\n  const C = d * h - e * g;\r\n  const D = -(b * i - c * h);\r\n  const E = a * i - c * g;\r\n  const F = -(a * h - b * g);\r\n  const G = b * f - c * e;\r\n  const H = -(a * f - c * d);\r\n  const I = a * e - b * d;\r\n  const det = a * A + b * B + c * C;\r\n  if (det === 0) throw new Error('Singular matrix');\r\n  return [\r\n    [A / det, D / det, G / det],\r\n    [B / det, E / det, H / det],\r\n    [C / det, F / det, I / det]\r\n  ];\r\n}\r\n\r\nfunction warpTransform(ctx, image, matrix, outWidth, outHeight) {\r\n  // Inverse matrix for mapping output to input\r\n  const inv = invert3x3(matrix);\r\n  // Get source image data\r\n  const srcCanvas = document.createElement('canvas');\r\n  srcCanvas.width = image.width || image.naturalWidth;\r\n  srcCanvas.height = image.height || image.naturalHeight;\r\n  const srcCtx = srcCanvas.getContext('2d');\r\n  srcCtx.drawImage(image, 0, 0, srcCanvas.width, srcCanvas.height);\r\n  const srcData = srcCtx.getImageData(0, 0, srcCanvas.width, srcCanvas.height);\r\n  const out = ctx.createImageData(outWidth, outHeight);\r\n  for (let y = 0; y < outHeight; y++) {\r\n    for (let x = 0; x < outWidth; x++) {\r\n      // Map (x, y) in output to (srcX, srcY) in input\r\n      const denom = inv[2][0] * x + inv[2][1] * y + inv[2][2];\r\n      const srcX = (inv[0][0] * x + inv[0][1] * y + inv[0][2]) / denom;\r\n      const srcY = (inv[1][0] * x + inv[1][1] * y + inv[1][2]) / denom;\r\n      // Bilinear sample\r\n      const sx = Math.max(0, Math.min(srcCanvas.width - 2, srcX));\r\n      const sy = Math.max(0, Math.min(srcCanvas.height - 2, srcY));\r\n      const ix = Math.floor(sx), iy = Math.floor(sy);\r\n      const dx = sx - ix, dy = sy - iy;\r\n      for (let c = 0; c < 4; c++) {\r\n        // Bilinear interpolation\r\n        const i00 = srcData.data[(iy * srcCanvas.width + ix) * 4 + c];\r\n        const i10 = srcData.data[(iy * srcCanvas.width + (ix + 1)) * 4 + c];\r\n        const i01 = srcData.data[((iy + 1) * srcCanvas.width + ix) * 4 + c];\r\n        const i11 = srcData.data[((iy + 1) * srcCanvas.width + (ix + 1)) * 4 + c];\r\n        out.data[(y * outWidth + x) * 4 + c] =\r\n          (1 - dx) * (1 - dy) * i00 +\r\n          dx * (1 - dy) * i10 +\r\n          (1 - dx) * dy * i01 +\r\n          dx * dy * i11;\r\n      }\r\n    }\r\n  }\r\n  ctx.putImageData(out, 0, 0);\r\n}\r\n\r\n\r\n/**\r\n * Extract document with manual corner points (no detection).\r\n * @param {HTMLImageElement|HTMLCanvasElement|ImageData} image\r\n * @param {Object} corners - Corner points object with topLeft, topRight, bottomRight, bottomLeft\r\n * @param {Object} options\r\n *   - output: 'canvas' | 'imagedata' | 'dataurl' (default: 'canvas')\r\n * @returns {Promise<{output, corners, success, message}>}\r\n */\r\nexport async function extractDocument(image, corners, options = {}) {\r\n  const outputType = options.output || 'canvas';\r\n\r\n  if (!corners || !corners.topLeft || !corners.topRight || !corners.bottomRight || !corners.bottomLeft) {\r\n    return {\r\n      output: null,\r\n      corners: null,\r\n      success: false,\r\n      message: 'Invalid corner points provided'\r\n    };\r\n  }\r\n\r\n  try {\r\n    // Create result canvas and extract document\r\n    const resultCanvas = document.createElement('canvas');\r\n    const ctx = resultCanvas.getContext('2d');\r\n    unwarpImage(ctx, image, corners);\r\n\r\n    let output;\r\n    // Prepare output in requested format\r\n    if (outputType === 'canvas') {\r\n      output = resultCanvas;\r\n    } else if (outputType === 'imagedata') {\r\n      output = resultCanvas.getContext('2d').getImageData(0, 0, resultCanvas.width, resultCanvas.height);\r\n    } else if (outputType === 'dataurl') {\r\n      output = resultCanvas.toDataURL();\r\n    } else {\r\n      output = resultCanvas;\r\n    }\r\n\r\n    return {\r\n      output,\r\n      corners,\r\n      success: true,\r\n      message: 'Document extracted successfully'\r\n    };\r\n  } catch (error) {\r\n    return {\r\n      output: null,\r\n      corners,\r\n      success: false,\r\n      message: `Extraction failed: ${error.message}`\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Main entry point for document scanning.\r\n * @param {HTMLImageElement|HTMLCanvasElement|ImageData} image\r\n * @param {Object} options\r\n *   - mode: 'detect' | 'extract' (default: 'detect')\r\n *   - output: 'canvas' | 'imagedata' | 'dataurl' (default: 'canvas')\r\n *   - debug: boolean\r\n *   - ...other detection options\r\n * @returns {Promise<{output, corners, contour, debug, success, message}>}\r\n */\r\nexport async function scanDocument(image, options = {}) {\r\n  const mode = options.mode || 'detect';\r\n  const outputType = options.output || 'canvas';\r\n  const debug = !!options.debug;\r\n\r\n  // Prepare input image data\r\n  let imageData, width, height;\r\n  if (image instanceof ImageData) {\r\n    imageData = image;\r\n    width = image.width;\r\n    height = image.height;\r\n  } else {\r\n    // HTMLImageElement or HTMLCanvasElement\r\n    const tempCanvas = document.createElement('canvas');\r\n    tempCanvas.width = image.width || image.naturalWidth;\r\n    tempCanvas.height = image.height || image.naturalHeight;\r\n    const tempCtx = tempCanvas.getContext('2d');\r\n    tempCtx.drawImage(image, 0, 0, tempCanvas.width, tempCanvas.height);\r\n    imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);\r\n    width = tempCanvas.width;\r\n    height = tempCanvas.height;\r\n  }\r\n\r\n  // Detect document\r\n  const detection = await detectDocumentInternal(imageData, options);\r\n  if (!detection.success) {\r\n    return {\r\n      output: null,\r\n      corners: null,\r\n      contour: null,\r\n      debug: detection.debug,\r\n      success: false,\r\n      message: detection.message || 'No document detected'\r\n    };\r\n  }\r\n\r\n  let resultCanvas;\r\n  let output;\r\n\r\n  if (mode === 'detect') {\r\n    // Just return detection info, no image processing\r\n    output = null;\r\n  } else if (mode === 'extract') {\r\n    // Return only the cropped/warped document\r\n    resultCanvas = document.createElement('canvas');\r\n    const ctx = resultCanvas.getContext('2d');\r\n    unwarpImage(ctx, image, detection.corners);\r\n  }\r\n\r\n  // Prepare output in requested format (only if not detect mode)\r\n  if (mode !== 'detect' && resultCanvas) {\r\n    if (outputType === 'canvas') {\r\n      output = resultCanvas;\r\n    } else if (outputType === 'imagedata') {\r\n      output = resultCanvas.getContext('2d').getImageData(0, 0, resultCanvas.width, resultCanvas.height);\r\n    } else if (outputType === 'dataurl') {\r\n      output = resultCanvas.toDataURL();\r\n    } else {\r\n      output = resultCanvas;\r\n    }\r\n  }\r\n\r\n  return {\r\n    output,\r\n    corners: detection.corners,\r\n    contour: detection.contour,\r\n    debug: detection.debug,\r\n    success: true,\r\n    message: 'Document detected'\r\n  };\r\n}\r\n\r\n// Export enhanced detection functions\r\nexport {\r\n  enhancedDocumentDetection,\r\n  quickDocumentDetection,\r\n  detectIDDocument,\r\n  enhancedEdgeDetection,\r\n  detectDocumentHough,\r\n  DETECTION_PRESETS,\r\n} from './enhancedDetection.js';"],"names":["DEFAULTS","RETR_EXTERNAL","RETR_LIST","CHAIN_APPROX_SIMPLE","deltas","detectDocumentContour","edges","options","width","height","mode","method","minArea","paddedWidth","paddedHeight","labels","y","x","contours","nextContourId","currentPixelLabel","leftPixelLabel","startPoint","isOuter","initialDirection","contourId","points","traceContour","finalPoints","simplifyChainApproxSimple","adjustedPoints","p","contour","calculateContourArea","calculateBoundingBox","filteredContours","a","b","visitedPoints","currentPoint","prevDirection","count","maxSteps","searchDirection","found","i","nextX","nextY","nextPoint","checkDirection","checkX","checkY","pointKey","simplifiedPoints","n","prevPoint","dx1","dy1","dx2","dy2","maxDistSq","farthestIdx","p0","pi","distSq","area","j","minX","minY","maxX","maxY","point","simplifyContour","epsilon","maxDistance","index","firstPoint","lastPoint","distance","perpendicularDistance","firstSegment","secondSegment","lineStart","lineEnd","dx","dy","lineLengthSq","t","closestPointX","closestPointY","distDx","distDy","approximatePolygon","contourPoints","perimeter","calculateContourPerimeter","actualEpsilon","findCenter","sumX","sumY","findCornerPoints","approximation","corners","orderCornerPoints","findCornersByCoordinateExtremes","topLeft","topRight","bottomRight","bottomLeft","minSum","maxDiff","maxSum","minDiff","sum","diff","center","sortedPoints","angleA","angleB","minIndex","orderedPoints","wasm","cachedFloat32ArrayMemory0","getFloat32ArrayMemory0","WASM_VECTOR_LEN","passArrayF32ToWasm0","arg","malloc","ptr","getArrayF32FromWasm0","len","find_document_quadrilateral","lines","min_area_ratio","max_area_ratio","ptr0","len0","ret","v2","cachedUint8ArrayMemory0","getUint8ArrayMemory0","passArray8ToWasm0","hough_lines","rho_resolution","theta_resolution","threshold","max_lines","getArrayU8FromWasm0","close_edge_gaps","gap_size","remove_small_components","binary","min_area","thin_edges","compute_adaptive_canny_thresholds","magnitude","low_ratio","high_ratio","otsu_threshold","input","clahe","tile_grid_x","tile_grid_y","clip_limit","contrast_stretch","illumination_normalize","sigma","blur","grayscale","kernel_size","cachedUint16ArrayMemory0","getUint16ArrayMemory0","passArray16ToWasm0","refine_corners_subpixel","gradients","search_radius","ptr1","len1","v3","calculate_size_score","image_width","image_height","min_coverage","max_coverage","ideal_coverage","validate_quadrilateral","calculate_detection_confidence","edge_score","shape_score","aspect_score","size_score","calculate_edge_strength","sample_points","cachedInt16ArrayMemory0","getInt16ArrayMemory0","getArrayI16FromWasm0","non_maximum_suppression","l2_gradient","dilate","nms_precise","direction","sobel_gradients_3x3","sobel_gradients_3x3_simd","sobel_gradients_5x5","gradient_magnitude_direction","l2_norm","scharr_gradients_3x3","hysteresis_thresholding","suppressed","low_threshold","high_threshold","__wbg_load","module","imports","e","bytes","instance","__wbg_get_imports","table","offset","__wbg_finalize_init","__wbg_init","module_or_path","wasmReady","init","convertToGrayscale","imageData","data","gaussianBlurGrayscale","kernelSize","halfKernel","kernel","createGaussianKernel","tempArray","blurred","rowOffset","k","xOffset","yOffset","size","halfSize","calculateGradients","prevRowOffset","nextRowOffset","currentIdx","p1","p2","p3","p5","p6","p7","p8","gx","gy","nonMaximumSuppression","L2gradient","idx","mag","neighbor1","neighbor2","absGx","absGy","s","hysteresisThresholding","lowThreshold","highThreshold","edgeMap","stack","dxNeighbors","dyNeighbors","nx","ny","nidx","dilateEdges","temp","dilated","maxVal","val","cannyEdgeDetector","timings","tStart","applyDilation","dilationKernelSize","useWasmHysteresis","t0","t1","wasmBlur","wasmMaximumSuppression","finalLowThreshold","finalHighThreshold","wasmHysteresis","cannyEdges","finalEdges","wasmDilate","tEnd","DETECTION_PRESETS","preprocessImage","processed","wasmIlluminationNormalize","wasmClahe","wasmContrastStretch","operator","wasmScharr3x3","wasmSobel5x5","wasmSobel3x3Simd","wasmSobel3x3","elapsed","computeAdaptiveThresholds","magnitudeU8","maxMag","otsuThresh","wasmOtsuThreshold","thresholds","wasmComputeCannyThresholds","enhancedEdgeDetection","config","preprocessing","edgeConfig","postConfig","debug","prepTimings","gradientTime","magDir","wasmGradientMagDir","wasmNmsPrecise","adaptive","performHysteresis","postProcessed","wasmCloseEdgeGaps","wasmRemoveSmallComponents","wasmThinEdges","output","visited","offsets","detectDocumentHough","wasmHoughLines","numLines","quad","wasmFindQuadrilateral","parseLines","lineConfidence","validation","wasmValidateQuadrilateral","validationResult","sizeScore","wasmCalculateSizeScore","confidence","wasmCalculateConfidence","result","enhancedDocumentDetection","preset","mergedConfig","edgeResult","detection","cornersArray","edgeScore","wasmCalculateEdgeStrength","refined","wasmRefineCorners","quickDocumentDetection","detectIDDocument","calculateAdaptiveDownscale","maxDimension","maxCurrentDimension","scaleFactor","scaledWidth","scaledHeight","tempCanvas","scaledCanvas","scaledCtx","detectDocumentInternal","debugInfo","maxProcessingDimension","scaledImageData","originalDimensions","scaledDimensions","documentContour","cornerPoints","finalCorners","getPerspectiveTransform","srcPoints","dstPoints","buildMatrix","matrix","A","solve","m","M","row","B","maxRow","h","unwarpImage","ctx","image","widthA","widthB","maxWidth","heightA","heightB","maxHeight","perspectiveMatrix","warpTransform","invert3x3","c","d","f","g","C","D","E","F","G","H","I","det","outWidth","outHeight","inv","srcCanvas","srcCtx","srcData","out","denom","srcX","srcY","sx","sy","ix","iy","i00","i10","i01","i11","extractDocument","outputType","resultCanvas","error","scanDocument","tempCtx"],"mappings":"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"}